% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{url}

\newcommand{\SunroofAnalog}[1]{#1\ensuremath{_\downarrow}}
\newcommand{\HaskellAnalog}[1]{#1\ensuremath{_\uparrow}}

%\newcommand{\NOTE}[1]{{\Large\textbf{NOTE:}\ #1}}
\newcommand{\TODO}[1]{{(\textbf{TODO:}\ #1)}}
\newcommand{\Src}[1]{{\tt{#1}}}

\newcommand{\IO}{\Src{IO}}
\newcommand{\JS}{\Src{JS}}
\newcommand{\JSI}{\Src{JSI}}
\newcommand{\JSA}{\ensuremath{\Src{JS}_\Src{A}}}
\newcommand{\JSB}{\ensuremath{\Src{JS}_\Src{B}}}

\newcommand{\Figure}[3]{%
\FigureS{#1}{#2}{#3}{scale=0.55,clip=true,trim=0.45cm 0.45cm 0.45cm 0.45cm}
}

\newcommand{\FigureS}[4]{%
\begin{figure}[t]%
%\vspace{-0.5cm}%
\begin{center}%
\includegraphics[#4]{#2}%
\vspace{-0.5cm}%
\end{center}%
\caption{#3}%
\label{#1}%
\end{figure}%
}

\newenvironment{Code}{\verbatim}{\endverbatim}

\newcommand{\FigRef}[1]{Fig.~\ref{#1}}
\newcommand{\SecRef}[1]{Section~\ref{#1}}
\newcommand{\TabRef}[1]{Table~\ref{#1}}

% intentional for the referee's copy
\pagestyle{plain}
\newcommand{\CURSOR}{\noindent\rule{\textwidth}{4pt}}

\begin{document}
%
\title{Sunroof: A Monadic DSL for Generating JavaScript}
%\subtitle{}
%
\titlerunning{Sunroof}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Jan Bracker\inst{1} and Andy Gill\inst{2}}
%
\authorrunning{Jan Bracker \and Andy Gill} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Andy Gill, Jan Bracker}
%
\institute{%
Institut f{\"u}r Informatik\\
Christian-Albrechts-Universit{\"a}t, Kiel, Germany\\
~\\
\and
ITTC / EECS \\
The University of Kansas, Lawrence, KS 66045}

\maketitle

\begin{abstract}        
Sunroof is a Haskell-hosted Domain Specific Language (DSL) for generating JavaScript.
Sunroof is built on top of the JavaScript monad, which, like the Haskell \IO-monad, allows 
access to external resources, but specifically JavaScript
resources. As such, Sunroof is primarily a feature-rich 
foreign-function API to the browser's JavaScript engine, and all the browser-specific
functionality, including HTML-based rendering, event handling, and 
drawing to the HTML5 {\tt canvas} element. 

In this paper, we give the design and implementation of Sunroof.
Using monadic reification, we generate JavaScript from
a deep embedding of the JavaScript monad.
The Sunroof DSL has the feel of native Haskell, with a simple
Haskell-based type schema to guide the Sunroof programmer.
Furthermore, because we are generating code,
we can offer Haskell-style concurrency patterns, such as MVars and Channels.
In combination with a web-services package,
the Sunroof compiler offers a robust platform to build interactive web applications.

\keywords{DSLs, JavaScript, Web Technologies, Cloud Computing}
\end{abstract}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:intro}

% Simon: Describe the problem
There are many reasons to want to program in a functional language:
efficiency of development, formal and informal reasoning, and high-level 
control- and concurrency-structures, such as monads~\cite{Moggi:89:LambdaMonads}.
However, mainstream languages often have better environmental support
than what is provided by functional language compilers,
for example the Objective C and the iOS ecosystem, or JavaScript and HTML5
web browsers.
This paper examines the challenges of providing
an intentionally blurred interface between Haskell
and JavaScript, to support the development of web-based applications.

% Simon: State your contributions
JavaScript is an imperative language with access to a wide range
of established and useful services like graphical canvases and event
handling of browser events. 
We want to express JavaScript in Haskell, adding use
of Haskell's static typing, and gaining access to JavaScript services
in the browser directly from Haskell.


One way of providing access to non-native services,
such as the HTML5 canvas, is to provide, in Haskell, 
foreign function ``hooks'' to key JavaScript functionality,
and compile Haskell to JavaScript by rewriting the
compiler backend.
Haskell already provides many similar hooks into the C RTS,
so why not into JavaScript?
There are already a number of systems attempting this~\cite{Stutterheim:12:ImprovingUHCJavaScriptBackend,project:ghcjs}.
If executed well, this would be ideal,
but there are engineering shortcomings: 
many standard libraries and Hackage packages are not supported directly,
the generated code is not as efficiently executed as native Haskell, and
the runtime system is often incomplete. These compilers will continue
to improve, and with initiatives like asm.js~\cite{url:asmjs.org}
and Emscripten~\cite{project:emscripten},
the efficiency gap will close.

Rather than rewrite the compiler and runtime system,
an alternative approach is to keep the existing
runtime system, and provide the same 
foreign function ``hooks'' to key JavaScript functionality,
but instead the executed Haskell becomes a server that JavaScript,
and the browser, interact with.
Unfortunately, every JavaScript call becomes an expensive proposition: a Remote Procedure Call (RPC)
to a browser.
Though some straight-line calls can be batched together --
our own blank-canvas Hackage package~\cite{Hackage:11:blank-canvas} was built on this idea --
the granularity of interaction through JavaScript calls is just too fine for
this idea to scale well.

Another approach, and the one we investigate,
is to use a deeply embedded Domain Specific Language (DSL), and
recently discovered monad reification~\cite{Persson:11:GenericMonadicConstructs,Farmer:12:WebDSLs,Sculthorpe:13:ConstrainedMonads,Svenningsson:13:CompositionalMonadReification}.
A Haskell-hosted deeply embedded DSL is where Haskell combinators 
are used to build syntactical forms in the target language,
in this case JavaScript.
Historically, these embeddings have worked well for 
data-flow, for example generating combinatorial hardware,
but had serious challenges with capturing binding and control flow.
Monad reification, where the monad itself is representable in the deep embedding,
partially mitigates this shortcoming, allowing statements and
effectful bindings to be expressed directly.

Sunroof is an exercise in scaling up the use of monad reification,
and other domain specific language techniques, to a full-scale JavaScript DSL.
With Sunroof bindings being regular Haskell monadic bindings, 
the language fits with what would be expected from a monadic API. 
In a previous paper, we showed, using a prototype,
that reification of a JavaScript-like language is possible~\cite{Farmer:12:WebDSLs}.
In this paper, we expand on this observation,
and show that monadic-reification is useful in practice.

Building on this DSL, we also investigate providing
JavaScript control flow and function abstraction mechanisms
to the Haskell programmer interested in using the browser API.
Though for technical reasons we can not directly compile
pattern matching and let-binding to JavaScript without committing
to a full Haskell to JavaScript compiler, both
control flow and function abstraction can be provided
with a small syntactical overhead, and reifiable fix-points 
can be provided with a modest syntactical overhead.
With these capabilities, a programmer can start programming
using the JavaScript API directly, and refine
their program to migrate more and more computation
from the server into the browser. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Calling JavaScript from Haskell}
\label{sec:js-rpc}

From a programmers' point of view, calling JavaScript functions
appears straightforward. We, as                                                                                                                      acommunity know how to reflect an
API into Haskell, using the IO monad. Furthermore, objects in
the target API become handles in Haskell. 

As a first example, consider this simplified example of Sunroof code, and corresponding JavaScript.
\noindent
\begin{Code}
-- Haskell                          // JavaScript
ioCode :: IO ()
ioCode = send jsCode

jsCode :: JS ()
jsCode = do                        function jsCode() {
   name <- prompt "Your name?"       var name = prompt("Your name?"); 
   alert ("Your name: " <> name)     alert("Your name: " + name); 
                                   }
\end{Code}%     
%\noindent 

Here, we use a new monad, the \Src{JS} monad, our JavaScript
analog of the \Src{IO} monad,
and an explicit \Src{send} command that sends the JavaScript to the browser.
This reversal of control, where the
server sends the client commands, follows the Comet AJAX application model.
In this case, the Comet interaction is implemented by {\em long polling\/} on behalf of the client.
This interface bundles the \Src{prompt} and \Src{alert} commands
into a single interaction.
It is this flavor of interface we want to support in our Sunroof compiler
and web server.  

To make Sunroof a viable interface to JavaScript, we need to
resolve the following issues:
\begin{itemize}
\item JavaScript is an object-based, imperative, dynamically typed language.
Haskell is a pure, function-based, statically typed language.
In Section~\ref{sec:object-model}, we introduce expressions and statements
in Sunroof, and show how they jointly form an object model,
mapping these two worlds together.
%
\item We need to select a concurrency model for Sunroof.
Natively, JavaScript only supports non-blockable threads.
In Section~\ref{sec:threading-models}, we give the
Sunroof interface for providing both non-blocking and blocking cooperative threads,
using the type system to delimit the two concurrency models.
%
\item We choose to provide a way of defining functions
in Sunroof such that they are first-class functions
in JavaScript. In Section~\ref{sec:functions-continuations},
we show how we support both functions and continuations.
%
\item We need to provide a foreign function interface,
to allow us to call specific JavaScript-native functions,
like \Src{prompt} and \Src{alert}.
In Section~\ref{sec:ffi} we present this interface.
%
\item Critically, we need to be able to compile our Sunroof DSL
into JavaScript. We examine this in Section~\ref{sec:compiler}.
\item To enable the compiled code to dynamically interact with
a web browser, we provide an expansion of the \Src{send} idea above,
which we discuss in Section~\ref{sec:server}.
\end{itemize}

\noindent
We close with a small case study, related work, and our conclusions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Sunroof Expressions and Statements} % TODO: rename
\label{sec:object-model}

JavaScript makes a distinction between expressions and statements.
Sunroof is a typed version of JavaScript, so therefore also
make this distinction, and does so using Haskell types.

\subsection{Sunroof Expressions}


\begin{table}[t]
\begin{center}
\begin{tabular}{r@{\quad}l@{\quad}l@{\quad}c}
\hline\rule{0pt}{12pt}%
  Constraint
  & Sunroof Type $\tau$
  & Haskell Analog \HaskellAnalog{$\tau$}
  & \Src{js} \\ \hline\rule{0pt}{12pt}%
  
  & \Src{()}       & \Src{()}     & $\checkmark$ \\
  & \Src{JSBool}   & \Src{Bool}   & $\checkmark$ \\
  & \Src{JSNumber} & \Src{Double} & $\checkmark$ \\
  & \Src{JSString} & \Src{String} & $\checkmark$ \\
  
  \Src{Sunroof $\alpha$}
  & \Src{JSArray $\alpha$} 
  & \Src{[$\HaskellAnalog{\alpha}$]}
  & \\
  
  \Src{SunroofKey $\alpha$}
  & \Src{JSMap $\alpha$ $\beta$}
  & \Src{Map $\HaskellAnalog{\alpha}$ $\HaskellAnalog{\beta}$}
  & \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSFunction $\alpha$ $\beta$ }
  & \Src{$\HaskellAnalog{\alpha}$ $\rightarrow$ JS$_\Src{A}$ $\HaskellAnalog{\beta}$} 
  & \\
  \Src{Sunroof $\beta$} \\

  \Src{SunroofArgument $\alpha$}
  & \Src{JSContinuation $\alpha$}
  & \Src{$\HaskellAnalog{\alpha}$ $\rightarrow$ JS$_\Src{B}$ $\beta$} 
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSMVar $\alpha$}
  & \Src{MVar $\HaskellAnalog{\alpha}$}
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSChan $\alpha$}
  & \Src{Chan $\HaskellAnalog{\alpha}$}
  & \\[2pt]
\hline
\end{tabular}
\end{center}
\caption{Sunroof types and their Haskell analogs.}
\vspace{-0.2in}
\label{tab:sunroof-types}
\end{table} 

In JavaScript, there are a small number of core types, such as \Src{object}, \Src{array}, and \Src{string}.
In our JavaScript object model, there is a reflection of this family of core types, all prefixed with \Src{JS}.
There is support for booleans, strings, numbers, functions,
arrays, and other common programming structures.
The use of \Src{JSNumber}, rather than (say) \Src{Double},
explicitly reminds us of the enforced diminished capabilities of
being within an embedded language,
and all of the \Src{JS}-types are representable in our target language.
Table~\ref{tab:sunroof-types} enumerates the major \Src{JS} types used in Sunroof.
%
The left-hand column of Table~\ref{tab:sunroof-types} gives constraints,
implemented via Haskell type classes.
\begin{itemize}
\item  All our core types are brought together with the \Src{Sunroof} class.
If a type is an instance of \Src{Sunroof}, then that type can be realized inside JavaScript.
All the \Src{JS} types are instances of \Src{Sunroof}.

\item Instances of the \Src{SunroofArgument} class
are values that can be passed to JavaScript functions and methods,
including tuples of values which are used for representing multi-argument 
function calls.
The asymmetry here is a reflection of the JavaScript
asymmetry inherited from C: you can pass multiple arguments
to a function, but only get a single thing back.

\item Finally, there is a third class, \Src{SunroofKey}, which is
is a JavaScript version of the Haskell \Src{Show} class,
but specifically for generating JavaScript object keys,
which are realized as JavaScript strings.
\end{itemize}

Using our \Src{JS}-types, we can build expressions using the traditional Haskell expression-building
mechanisms. \Src{JSNumber} is overloaded, and thus can be used directly for arithmetic.
\Src{JSBool} is an instance of the relevant classes in the Hackage package \verb|boolean|.
Further, \Src{JSString} is a \Src{Monoid}, which is only possible because JavaScript
strings are immutable values.

To help the conversion between classical Haskell values and Sunroof values,
we provide the overloaded function \Src{js}. The right-hand column of 
table~\ref{tab:sunroof-types} shows what types can be converted, using \Src{js}.
The full types of \Src{js} is:
\begin{Code}
js :: (SunroofValue a, Sunroof (ValueOf a)) => a -> ValueOf a
\end{Code}
\Src{SunroofValue} and the type function~\cite{Chakravarty:05:AssociatedTypes}~\Src{ValueOf} represent the mapping given in the table.
%
Putting the expression-building capability together, 
along with a show function called \Src{toString}, we can write:
\begin{Code}
  alert ("n=" <> js (n::Int) <> " m=" <> toString (m::JSNumber))
\end{Code}
Here, \Src{n} is a Haskell \Src{Int}, and \Src{m} is a Sunroof number,
presumably the result of a previous computation. Given that we are 
bundling expressions to send to a browser for execution, \Src{n}
is a static value, and \Src{m} is a dynamic value, unobservable until inside our browser's execution.
Finally, \Src{toString} has type:
\begin{Code}
toString :: Sunroof a => a -> JSString
\end{Code}

One design decision in Sunroof is that we enforce a stronger typing than JavaScript itself would.
Specifically, there are restrictions on the type arguments of our container types,
like \Src{JSArray}. What can be seen from this is that we
enforce a Hindleyâ€“Milner style thinking to our containers,
which is distinct from JavaScript dynamic typing.
Some types involve
phantom types to enforce this imposed type safety \cite{Leijen:99:Phantom}.
Thus, \Src{JSArray} is a restricted type of JavaScript \Src{array}, that, like Haskell,
only supports collections of the same type.

From experience with using Sunroof,
the mis-match in typing between Haskell and Sunroof/JavaScript
is not large problem in practice.
However, sometime casting between types, which is implicit in JavaScript,
is needed. So we provide an explicit dynamic \Src{cast},
for use where the type-systems differ,
and both sides of the \Src{cast} are instances of \Src{Sunroof}.
\begin{Code}
cast :: (Sunroof a, Sunroof b) => a -> b
\end{Code}

\subsection{Sunroof Statements}

The building block of object-oriented programing is calling an object's method.
This is almost universally done using the dot (\Src{.}) operator. JavaScript, our target language, 
follows this trend, with the method-call syntax being as follows:
\begin{Code}
  object.method(a1,a2,a3,...,aN)   // JavaScript method call
\end{Code}
For our Sunroof object model, we want to follow this as closely as possible.

\newpage\noindent
We, have our method calls use a monad because method calls are effectful.
By convention, we take the object as the {\em last\/} argument.
\begin{Code}
// Shape of a Sunroof method
(SunroofArgument args, Sunroof res) => args -> (JSObject -> JS res)
\end{Code}
A neat way of writing method calls in Haskell is transcribing the JavaScript dot, which is already use
for both namespace resolution and function composition in Haskell, with the \Src{\#} combinator~\cite{Shields:01:Babel}.
The \Src{\#} combinator simply applies the second argument to the first (object) argument.
\begin{Code}
// Sunroof        
(#) :: a -> (a -> JS b) -> JS b
(#) obj act = act obj
\end{Code}

\noindent
This gives the follow fragment for a Sunroof call to \Src{method} on \Src{object}.
\begin{Code}
  object # method (a1,a2,a3,...,aN)
\end{Code}
In this way, JavaScript can be transliterated into Haskell where needed,
native JavaScript call idioms can be used,
while other Haskell abstraction mechanisms can be used for the interface that calls Sunroof code.

We piece together our Sunroof method calls using the Haskell support for monads.
\begin{Code}
  do r1 <- obj # method1 (a1,a2,a3,...,aN)
     r2 <- obj # method2 ({-... can use r1 ...-})
     ....
\end{Code} 
In this fragment, \Src{r1} is bound to the result of the \Src{method1} call,
and can be used as an argument to \Src{method2}.

Sometimes, a JavaScript API requires direct access to object attributes.
We do so using a typed \Src{JSSelector}.
\begin{Code}
label :: JSString -> JSSelector a
(!)   :: (Sunroof o, Sunroof a) => o -> JSSelector a -> a
(:=)  :: (Sunroof a, Sunroof o) => JSSelector a -> a -> (o -> JS t ())
\end{Code}
We can build a selector (\Src{label}), use a selector to access a attribute in a specific
object (\Src{!}), or update an attribute in a specific object (\Src{:=}).
The update is in our object-normal-form, that is the object is the final argument.
Sunroof is, in essence, a strict functional language, with monads for effect.
We choose to support direct (non-monadic) reading of attributes, but
all updating of objects requires the monad.
This is a design decision we may return to in the future.
The net effect is that assignments to fields can be neatly expressed.
%with a syntax close to JavaScript itself. Our HTML5 canvas library,
%built on top of Sunroof primitives, allows the following transliteration
%from textbook JavaScript into Sunroof:
\begin{Code}
  // JavaScript                         // Sunroof
  c.fillStyle = "red";                  c # fillStyle := "red"
\end{Code}
Notice that `\Src{:=}' binds tighter then `\Src{\#}'; the `\Src{fillStyle := "red"}' is
effectively building and calling a setter method for `\Src{c}', on the fly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Threading Models}
\label{sec:threading-models}

JavaScript uses a callback-centric model of computation. There
is no support for concurrency, only a single central loop that executes
callbacks, which should be non-blocking, as events occur.
In contrast, Haskell has robust concurrency and wide-spread 
abstractions for synchronization, e.g. \Src{MVar}s and \Src{Chan}s
\cite{Jones:96:ConcurrentHaskell}.
So the question arises: do we generate non-blocking JavaScript code, 
and keep the callback centric model, or do we add concurrency
support as value-added by our transliteration to JavaScript?

In our earlier work~\cite{Farmer:12:WebDSLs}, we prototyped both blocking and non-blocking
translations, and observed that both choices had poor consequences.
\begin{itemize}
\item Existing JavaScript APIs assume atomic, non-blocking
semantics. Therefore, if we compile a higher-order function
for a callback, it must not block. 
Further, if this higher-order function returns a result, 
the function must respect this non-blocking requirement.
\item The lure of threads, and the abstractions they allow, 
is strong. Threaded code is -- from experience -- cleaner if 
directly used, rather that being faked in JavaScript itself.
There are new libraries in JavaScript that encode
some cooperative concurrency abstractions, like promises~\cite{url:taskjs.org};
Sunroof is a chance to translate using cooperative concurrency 
directly when generating JavaScript.
\end{itemize}
In our full-scale implementation of Sunroof,
we resolved this dilemma by
decided to explicitly support both blocking
and not-blocking threads,and use types to denote which
threading {\em strategies\/} should be used.
This means that the programmer can choose which concurrency model fits
the given situation.

In terms of user-interface, we parameterize the \JS-monad
with a phantom type that represents the threading model used, 
with \Src{A} for \Src{A}tomic,
and \Src{B} for \Src{B}locking threads. 
Atomic threads are classical JavaScript computations that
cannot be interrupted and actively use the callback
mechanism. Blocking threads can
support suspending operations and cooperative concurrency
abstractions as known from Haskell. By using phantom
types, we can express the necessary
restrictions on specific combinators, as well
as provide combinators to allow both types of
threads to cooperate.

The blocking model hides the callback mechanism behind abstractions.
This implies that every atomic computation can be converted into 
a potentially blocking computation. \Src{liftJS} achieves this.
\begin{Code}
liftJS :: Sunroof a => JS A a -> JS t a
\end{Code}

When suspending, we register our current
continuation as a callback to resume later. This gives other 
threads (registered continuations) a chance to run.
Of course, this model depends on cooperation between the threads,
because a not terminating or suspending thread will keep others from running.

There are two main primitives for the blocking model:
\begin{Code}
forkJS      :: SunroofThread t1 => JS t1 () -> JS t2 ()
threadDelay :: JSNumber -> JS B ()
\end{Code}
They can both be seen as analogs of their \IO~counterparts.
\Src{forkJS} resembles \Src{forkIO};
it registers the given computation as a callback. 
In \Src{forkJS}, the\linebreak\Src{SunroofThread} constraint allows the compiler
to know if this callback should be blocking or non-blocking,
based on the type of \Src{t1}. Both blocking and non-blocking
threads can fork new threads, so \Src{t2} is unconstrained.
\Src{threadDelay} sets a continuation callback to be called after a certain amount of time.
We rely on the JavaScript function \Src{window.setTimeout} 
\cite{whatwg:timers} to register our callbacks.

This parameterization of \Src{JS} allows us to use types to capture
the blocking semantics of our primitives.
Furthermore, the Haskell type system automatically propagates
the thread semantics. In this way, Sunroof can offer concurrency
as an additional, first class, abstraction.
As an example of what is possible, based on these primitive
threading combinators, consider Sunroof's
versions of Haskell's \Src{Chan}, called \Src{JSChan}.
The Sunroof API for \Src{JSChan} is as follows.
\begin{Code}
newChan   :: (SunroofArgument a) => JS t (JSChan a)
writeChan :: (SunroofArgument a) => a -> JSChan a -> JS t ()
readChan  :: (SunroofArgument a) => JSChan a -> JS B a
\end{Code}
Note that the types reflect if a specific operation can block.
Both \Src{newChan} and \Src{writeChan} can never block, so you can use either threading model,
but \Src{readChan} may block, so uses the \Src{B} threading model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Functions and Continuations}
\label{sec:functions-continuations}

Functions are first class values in Haskell and JavaScript.
Sunroof represents function {\em objects\/} with the type 
\Src{JSFunction $\alpha$ $\beta$}, which corresponds
to a function of type $\alpha \rightarrow \beta$ in JavaScript.
%In this section, we examine our solution to building functions
%in Sunroof.
In Sunroof, we create function objects with the \Src{function} combinator.
\begin{Code}
function :: (SunroofArgument a, Sunroof b) 
         => (a -> JS A b)  -> JS t (JSFunction a b)
\end{Code}
As a function can have side-effects, its computation and result have to be 
expressed in the \JS-monad. The creation of a function is considered 
a side-effect, due to observable allocation.
To see an example of usage, consider defining a \Src{double} function.
\begin{Code}
  double <- function $ \ (n :: JSNumber) -> return (n + n)
\end{Code}
Now \Src{double}, which has type \Src{JSFunction JSNumber JSNumber}, can
be stored in structures, passed to JavaScript functions, and enjoys
all the privileges of first-class JavaScript function objects.
\Src{function} acts as a staging combinator, converting  
a monadic Haskell function into a JavaScript-level function.

Function application of \Src{JSFunction} objects is done through 
the \Src{apply}/\Src{\$\$} combinator; they are synonyms.
Functions can only be applied in the \JS-monad, since they can have side-effects.
\begin{Code}
apply, ($$) :: (SunroofArgument a, Sunroof b) 
            => JSFunction a b -> a -> JS t b
\end{Code}
Together, \Src{function} and \Src{apply} give a way of getting into and
back from the abstract \Src{JSFunction} object. 

Sunroof also can express recursive functions, using a version
of the fixpoint combinator.
\begin{Code}
fixJS :: (SunroofArgument a) => (a -> JS A a) -> JS t a
\end{Code}
There is a self-imposed restriction that the higher-order function be
atomic, but the usage of \Src{fixJS} is straightforward, if verbose.
\begin{Code}
  fib <- fixJS $ \ (fib :: JSFunction JSNumber JSNumber) -> 
         function $ \ (n :: JSNumber) -> 
           ifB (n <* 2)
               (return 1)
               (liftM2 (+) (fib $$ (n - 1)) (fib $$ (n - 2)))
\end{Code}
Note that the `\Src{fib}' type here is a JSFunction object,
and we also need to use the \Src{JS} monad, because JavaScript
functions are effectful. % , but the function is expressible in Sunroof.

Continuations are functions that never return. JavaScript uses them; 
for example many callbacks are actually continuations. We can express
continuation objects (continuations in object form),
using the type \Src{JSContinuation$~\alpha$}.
Technically, \Src{JSContinuation $\alpha$} are only
specializations of functions, but
restricted to a specific threading model. Continuations
are meant to be a representation of side-effects -- 
ongoing computations inside the \JS-monad -- and might  
not terminate, so they do not return a value. As with functions, 
there is a combinator to create and apply a continuation.
\begin{Code}
continuation :: (SunroofArgument a) 
             => (a -> JS B ()) -> JS t (JSContinuation a)
goto         :: (SunroofArgument a) 
             => JSContinuation a -> a -> JS B ()
\end{Code}
The presented \Src{goto} should not be considered 
harmful \cite{Dijkstra:68:GotoConsideredHarmful}.
It calls a continuation,
as \Src{apply} calls functions.
The difference is that a call to \Src{goto} will never
return, as it executes the given continuation and abandons the 
current one -- the \Src{()} result is never returned.

Access to the current continuations is given through
the powerful call-with-current-continuation 
combinator \Src{callcc}.
\begin{Code}
callcc :: SunroofArgument a 
       => (JSContinuation a -> JS B a) -> JS B a
\end{Code}
%The current continuation models everything that 
%would usually happen after the call to \Src{callcc}. 

Functions and continuations, and their \Src{JS}-analogs,
are connected  to each other, as can be seen in \FigRef{fig:func-cont}.
\Figure%
{fig:func-cont}%
{figures/sunroof-func-cont.pdf}%
{How functions and continuations relate between the Haskell and Sunroof.}%
We can go back and forth between the Haskell and the Sunroof
representation of a function or continuation. But once a function
is specialized to a continuation, it is not possible to go back,
because continuations only model the side-effect, but do 
not return anything. \Src{kast} is just a specialized version of \Src{cast}.

% include discussion about one examp;e.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Foreign Function Interface}
\label{sec:ffi}

Sunroof also offers a simple foreign function interface, 
which enables us to easily 
access predefined JavaScript. There are four core functions:
\begin{Code}
fun    :: (SunroofArgument a, Sunroof r) 
       => String -> JSFunction a r
object :: String -> JSObject
new    :: (SunroofArgument a) 
       => String -> a -> JS t JSObject
invoke :: (SunroofArgument a, Sunroof o, Sunroof r) 
       => String -> a -> o -> JS t r
\end{Code}
\Src{fun} is used to create Sunroof functions from their names in JavaScript.
This can happen in two ways: either to call a function inline, or to 
create a real binding for that function. As an example, 
the \Src{alert} function can be called in line through \Src{fun "alert" \$\$ "text"},
or you can provide a binding in form of a Haskell function for it.
\begin{Code}
alert :: JSString -> JS t ()
alert s = fun "alert" $$ s
\end{Code}

Existing objects can be bound through the \Src{object} function, e.g.
the \Src{document} object is bound through \Src{object "document"}.
Constructors can be called using \Src{new}. To create a new
object you would call \Src{new "Object" ()}.

We can call methods of objects through \Src{invoke}. Again, this 
can be used inline and to create a real binding. An inline 
use of this to produce \linebreak\Src{document.getElementById("id")} would look like this: 
\begin{Code}
  object "document" # invoke "getElementById" "id"
\end{Code}

%\newpage\noindent
To provide a binding 
to the \Src{getElementById} method, one can write:
\begin{Code}
getElementById :: JSString -> JSObject -> JS t JSObject
getElementById s = invoke "getElementById" s
\end{Code}

Providing actual bindings ensures that
everything is typed correctly and prevents the need to resolve ambiguities 
through large type annotations inside of code.
%
The current release of Sunroof on Hackage provides bindings for most of the 
core browser API, the HTML5 Canvas element, and some of the JQuery API.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compiling Sunroof}
\label{sec:compiler}

Our domain specific language, embedded in Haskell, is useless unless
we can actually compile it to JavaScript. We apply four main techniques.
We believe Sunroof is the first time all four have been used simultaneously
in a full-scale embedded DSL.

\paragraph{Expression Reification:}
The first technique we use is capturing Sunroof expressions as expression trees. 
This is a classical use of a deeply-embedded language. Every expression/\Src{JS}-type
is a Haskell \Src{newtype} wrapper around an expression syntax tree.
This internal expression syntax is simple, with only five constructors:
literals, variable names, JavaScript `dot', application, and anonymous functions.
When compiling expressions, we use IO-based observable sharing~\cite{Gill:09:TypeSafeReification} internally.
We preserve a simple and monomorphic representation of our expression
type to allow our generated code to optionally contain types in comments --
this was especially useful for debugging.
Overall, this aspect of the Sunroof compiler is straightforward and unsurprising.

\paragraph{Function Reification:}
The second technique is we use is capturing functions, as delimited
by the \Src{function} combinator. Again, existing techniques can be used.
Consider this simple example: \Src{`Plus`} is the infix application of
the \Src{Plus} combinator.
\begin{Code}
data Expr = Plus Expr Expr | Lit Int | Var String

f :: Expr -> Expr
f x = x `Plus` (Lit 1)
\end{Code}

We can reify \Src{f} by applying it to \Src{(Var "x")}, where \Src{"x"} is a fresh name,
giving~\Src{Plus (Var "x") (Lit 1)}. By overloading the literals and arithmetic -- 
a common trick -- we can write a clean Haskell function that can still be reified:
\begin{Code}
f x = x + 1
\end{Code}

The Sunroof \Src{function} combinator reifies functions in exactly this way.
The type of the argument is constrained by the \Src{SunroofArgument} class,
and each instance of the class has a mechanism for generating a prototypical
argument, like \Src{(Var "x")} above. For example, a 2-tuple argument
would generate \linebreak\Src{(Var "x",Var "y")} as the template argument.

\paragraph{Monadic Reification:}

Monadic reification is the capture of monadic statements, including the bindings,
as an abstract syntax tree.
A GADT-based deep embedding of the specific monadic operations (bind, return), and the 
all the primitives (method call, etc.), 
allow the capture of the operations as abstract syntax trees.
The trick is normalizing the monadic
bind~\cite{Sculthorpe:13:ConstrainedMonads,Svenningsson:13:CompositionalMonadReification},
both in the GADT, and in a smart instance of the monadic bind.
\begin{Code}
data JS :: * -> * -> * where
  Return :: a -> JS t a
  Bind :: (Sunroof a) => JSPrim t a -> (a -> JS t b) -> JS t b

instance Monad (JS t) where
  return = Return
  (Return a) >>= k = k a                        -- left id
  (Bind va h) >>= Bind va (\ a -> h a >>= k)    -- assoc
\end{Code}  
Because \Src{Bind} is pre-normalized, constraints from the
\Src{JSPrim} GADT (not shown) can discharge the \Src{Sunroof} constraint.
Simplified, this is the compiler.
\begin{Code}
compileJS :: Sunroof a => JS a -> M (JSCode, a)
compileJS (Return a) = return ("",a) 
compileJS (Bind jx k) = do
   (c1,x)  <- compileJSPrim jx -- typechecks
   (c2, a) <- compileJS (k x)
   return (c1 ++ c2,a)

compileJSPrim :: Sunroof a => JSPrim a -> M (JSCode, a)
-- Implementation of compileJSPrim not given
\end{Code}
Counterintuitively, there can be a constraint on the GADT 
\Src{Bind} constructor which is not needed in the monad instance; indeed
it was thought to be impossible to have GADT constraints on
\Src{Bind} and still use the standard monad infrastructure.
For the technical details, including why it works, and what
generalizations are possible, see~\cite{Sculthorpe:13:ConstrainedMonads}.

\paragraph{CPS translation:}

Finally, we compile \Src{JS A} and \Src{JS B} differently with respect to control flow.
The compilation of \Src{JA A} is straightforward, and a transliteration.
The compilation of \Src{JS B} uses CPS internally, to give CPS-style JavaScript for
control flow. This compilation, though involved in the presence of the other
generalizations in Sunroof, is straightforward.

%The compiler offers two functions to compile either threading 
%model:
%\begin{Code}
%sunroofCompileJSA :: Sunroof a 
%                  => CompilerOpts -> String -> JS A a  -> IO String
%sunroofCompileJSB :: CompilerOpts -> String -> JS B () -> IO String
%\end{Code}
%Notice that for the blocking threading model only unit
%may be returned due to their continuation-based nature. 
%The string argument provides the name of the variable to which to
%bind the computation result.

\section{The Sunroof Server}
\label{sec:server}

The Sunroof server provides infrastructure to send arbitrary pieces 
of JavaScript to a web client for execution. 
It is thus possible to interleave Haskell and JavaScript 
computations as needed. The three major functions
provided are \Src{sunroofServer}, \Src{syncJS} and \Src{asyncJS}.
\begin{Code}
sunroofServer :: SunroofServerOptions 
              -> (SunroofEngine -> IO ()) 
              -> IO ()

syncJS  :: SunroofResult a 
        => SunroofEngine -> JS t a -> IO (ResultOf a)
asyncJS :: SunroofEngine -> JS t () -> IO ()
\end{Code}
\Src{SunroofEngine} is a handle into our specific web session, one per web application instance.
\Src{sunroofServer} starts a server that will call the given callback function
for each request.
\Src{syncJS} and \Src{asyncJS} allow the server
to run Sunroof code inside the requesting website.
\Src{asyncJS} executes it asynchronously without 
waiting for a return value. In contrast, 
\Src{syncJS} waits until the execution is complete and
then sends the result back to the server. It
is converted into a Haskell value that can be processed further. 
Values that can be converted to a Haskell type after a synchronous
call use the type function~\Src{ResultOf} to
allow \Src{JSString} to return a Haskell \Src{String}, 
\Src{JSNumber} to return \Src{Double}, etc.
% (as per the specification
%of JavaScript numbers), and \Src{()} to return \Src{()}.

\section{Case Study - A Small Calculator}
\label{sec:extended-example}

To see how Sunroof works in practice, we will look into the 
experience we gathered when writing a small calculator
for arithmetic expressions.
We use Sunroof to display our interface
and the results of our computation. Haskell was used to parse the 
arithmetic expressions and calculate the result. The Sunroof server 
was used to implement this JavaScript/Haskell hybrid.

The classical approach to develop an application like this would have 
been to write a server that provides a RESTful interface and replies 
through a JSON data structure. 
The client side of that application would have been written in JavaScript
directly.
Sunroof blurs this client/server distinction.
In Sunroof you can write the client-side code together with
your server application within Haskell. In our example, all code 
for the server and client is in Haskell. The control logic 
for the client side is provided through the server.
This leads to a tight coupling between both sides. 
This also shows how Sunroof blurs the border between the server 
and client side. You are not restricted by an interface or language 
barrier. If you need the client to do something, you can just 
send arbitrary Sunroof code to execute in the client.
%
\TabRef{tab:example-statistics} contains a few statistics 
about the size of the code in each part of the client.

The client-server response loop shuffles new input to the server 
and executes the response in the client.
%
Data conversion is needed, because pure Haskell data types
cannot be handled in Sunroof and vice versa -- there still
exists this language barrier between JavaScript and Haskell. 
Data-structure definitions must be written
to allow conversion between two essentially equal data structures.
However, there is great potential in automatically 
generating this code using techniques such as Template Haskell
\cite{Sheard:02:TemplateMetaProgrammingHaskell}.
Furthermore, this results in surprisingly readable JavaScript,
because these definitions are written to allow named object properties
to be used directly in the generated code.
%in the same way a native JavaScript %programer might.

The code for displaying the results is basically a 
transliteration of the JavaScript that you would write for this 
purpose.
The transliteration used here is not especially appealing,
but understandable to Haskell or JavaScript programmers.
In the future, this code can be generated through higher-level 
libraries with better abstractions, which should help.
Sunroof is intended to deliver a foundation for this purpose.
The rest of our code parses the arithmetic expression and calculate 
results is classical Haskell code. 

\begin{table}[t]
\begin{center}
\vspace{0.1in}
\begin{tabular}{l@{\quad}r@{\quad}r}
\hline\rule{0pt}{12pt}%
Part of Application & Lines of Code & Percentage \\[2pt]
\hline\rule{0pt}{12pt}%
Response loop & 25 & 6.5\% \\[2pt]
Data-structure descriptions & 85 & 22.0\% \\[2pt]
Rendering & 190 & 49.5\% \\[2pt]
Parsing and interpretation & 85 & 22.0\% \\[2pt]
\hline
\end{tabular}
\end{center}
\caption{Lines of code needed for the example.}
\label{tab:example-statistics}
\vspace{-0.5cm}
\end{table} 

Overall, we were pleased with how our case study went.
It was possible to write an entire (small) application
in Sunroof, and use native JavaScript APIs, and have
the entire application compile to JavaScript. 

\section{Related Work}

There have been several attempts to translate Haskell to JavaScript.
Prominent ones are the compiler backends for 
UHC \cite{Stutterheim:12:ImprovingUHCJavaScriptBackend} and 
GHCJS \cite{project:ghcjs}. There are also projects like Fay \cite{project:fay} 
that compile subsets of Haskell to JavaScript or JMacro \cite{project:jmacro}
which use quasiquotation \cite{Mainland:07:QuasiquotingHaskell} to embed 
a custom-tailored language into Haskell code.
%
At the same time there are also projects like 
CoffeeScript \cite{project:coffeescript} or LiveScript \cite{project:livescript}
to build custom languages 
that are very similar to JavaScript but add convenient syntax and
support for missing features.

Our approach to cooperative concurrency through continuations in JavaScript
has been used before 
\cite{Cooper:07:LinksWebProgrammingTiers,Predescu:02:CocoonContinuationBasedControlFlow}.
To our knowledge, creating a direct connection
between Haskell and JavaScript continuations has not been 
attempted before.

Deep embeddings of monads based on data structures have been used before
in Unimo \cite{Lin:06:Unimo} and Operational \cite{Apfelmus:10:Operational,Hackage:10:Operational}.
The specific approach Sunroof takes 
to monadic reification, and alternative implementation techniques,
are discussed in Sculthorpe et al. \cite{Sculthorpe:13:ConstrainedMonads} 
in detail.

Another effort to map a functional embedding to JavaScript is the JavaScript DSL
embedded inside Scala~\cite{Kossakowski:12:JED}
Rather than using a deep embedding, they use Lightweight Modular Staging (LMS)~\cite{Rompf:2010:LMS:1868294.1868314}.
Though the language specific challenges are different,
the two systems are comparable in capability.

The Sunroof server does not have the aim to provide a full-featured 
web framework, as HAppS, Snap or Yesod do. It only provides 
the infrastructure to communicate with the currently calling website
through the Kansas comet \cite{project:kansas-comet} 
push mechanism \cite{pattern:push}. 

To our knowledge, Sunroof is the only library that supports 
generation of JavaScript inside of Haskell using pure Haskell
in a type-safe manner. All other approaches discussed above
either require a separate compilation step or introduce new 
syntax inside of Haskell.
%
There also is an effort to generalize Active \cite{project:active}, a library for animations, and
implement a backend based on Sunroof \cite{project:sunroof-active}.
 
\section{Conclusion}

Sunroof takes the key idea of monad reification and
successfully creates a typed JavaScript language, based around the\JS-monad,
to describe computations intended for a JavaScript interpreter.
This paper documents our investigations since our initial prototype.
With pervasive use of types in Sunroof, and the concepts
of \Src{JSFunction} and \Src{JSContinuation}, there now is a 
clearer connection between
functions in the JavaScript and the Sunroof language space 
(\FigRef{fig:func-cont}). It is possible to go back and forth between 
both worlds. 

We were also able to create a two internal translations of our \JS{} monad,
one a direct transliteration,
and one based on on the translation of continuations from Haskell
to JavaScript. This enabled us to build applications
that use a blocking threading model on top of JavaScript
that resembles the model already known from Haskell.
Based on this model and the provided abstraction over continuations,
we can construct primitives like \Src{forkJS} or \Src{threadDelay},
and higher-level abstractions like \Src{JSMVar} and \Src{JSChan}.

We believe this is the first Haskell-to-JavaScript DSL that 
makes use of monadic reification. We think that this form
is reification gives a useful DSL, and we expect many future
DSLs to re-use this design pattern. 

The sunroof compiler,
server, and several examples, including our web-based unit tests,
are available on \Src{github.com/ku-fpg} and \Src{hackage.haskell.org}.
We plan to build a number of abstraction on top of Sunroof:
a port of diagrams~\cite{project:diagrams},
an animation DSL~\cite{project:active},
and a simple GUI toolkit for teaching functional programming.

%\input{sections/conclusion-discussion}

%\section{Acknowledgments}
%
%We want to thank Conal Elliott for his support in adapting 
%the Boolean package \cite{project:boolean} and helping us to
%extend it with support for deeply embedded numbers. 
%We would
%also like to thank the TFP referees for their useful feedback
%on an earlier version of this paper.

%
% ---- Bibliography ----
%
\bibliographystyle{splncs03}
\bibliography{sunroof}
\vspace{-0.5cm} % THIS SAVED MY LIFE

\end{document}

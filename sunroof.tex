% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{url}

\newcommand{\SunroofAnalog}[1]{#1\ensuremath{_\downarrow}}
\newcommand{\HaskellAnalog}[1]{#1\ensuremath{_\uparrow}}

%\newcommand{\NOTE}[1]{{\Large\textbf{NOTE:}\ #1}}
\newcommand{\TODO}[1]{{(\textbf{TODO:}\ #1)}}
\newcommand{\Src}[1]{{\tt{#1}}}

\newcommand{\IO}{\Src{IO}}
\newcommand{\JS}{\Src{JS}}
\newcommand{\JSI}{\Src{JSI}}
\newcommand{\JSA}{\ensuremath{\Src{JS}_\Src{A}}}
\newcommand{\JSB}{\ensuremath{\Src{JS}_\Src{B}}}

\newcommand{\Figure}[3]{%
\FigureS{#1}{#2}{#3}{scale=0.55,clip=true,trim=0.45cm 0.45cm 0.45cm 0.45cm}
}

\newcommand{\FigureS}[4]{%
\begin{figure}[t]%
%\vspace{-0.5cm}%
\begin{center}%
\includegraphics[#4]{#2}%
\vspace{-0.5cm}%
\end{center}%
\caption{#3}%
\label{#1}%
\vspace{-0.5cm}%
\end{figure}%
}

\newenvironment{Code}{\verbatim}{\endverbatim}

\newcommand{\FigRef}[1]{Fig.~\ref{#1}}
\newcommand{\SecRef}[1]{Section~\ref{#1}}
\newcommand{\TabRef}[1]{Table~\ref{#1}}

% intentional for the referee's copy
\pagestyle{plain}
\newcommand{\CURSOR}{\noindent\rule{\textwidth}{4pt}}

\begin{document}
%
\title{Sunroof: A Monadic DSL for Generating JavaScript}
%\subtitle{}
%
\titlerunning{Sunroof}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Andy Gill\inst{1} and Jan Bracker\inst{1,2}}
%
\authorrunning{Jan Bracker \and Andy Gill} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Andy Gill, Jan Bracker}
%
\institute{%
ITTC / EECS \\
The University of Kansas, Lawrence, KS 66045\\
~\\
\and
Institut f{\"u}r Informatik\\
Christian-Albrechts-Universit{\"a}t, Kiel, Germany}

\maketitle

\begin{abstract}        
Sunroof is a Haskell-hosted Domain Specific Language (DSL) for generating JavaScript.
Sunroof is built on top of the JavaScript monad, which, like the Haskell \IO-monad, allows 
access to external resources, but specifically JavaScript
resources. As such, Sunroof is primarily a feature-rich 
foreign-function API to the browser's JavaScript engine, and all the browser-specific
functionality, including HTML-based rendering, event handling, and 
drawing to the HTML5 canvas. 

In this paper, we give the design and implementation of Sunroof.
Using monadic reification, we generate JavaScript from
a deep embedding of the JavaScript monad.
The Sunroof DSL has the feel of native Haskell, with a simple
Haskell-based type schema to guide the Sunroof programmer.
Furthermore, because we are generating code,
we can offer Haskell-style concurrency patterns, such as MVars and Channels.
In combination with a web-services package,
the Sunroof compiler offers a robust platform to build interactive web applications.

\keywords{DSLs, JavaScript, Web Technologies, Cloud Computing}
\end{abstract}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:intro}

% Simon: Describe the problem
There are many reasons to want to program in a functional language:
efficiency of development cost, informally reasoning, high-level 
control- and concurrency-structures, like monads~\cite{...}.
However, mainstream languages often have better environmental support
than what is provided by functional languages,
for example the Objective C and the iOS eco-structure, or JavaScript and HTML5
web browsers.
This paper examines the challenges of providing
an intentionally blurred interface between Haskell
and JavaScript, to support the development of web-based applications.

% Simon: State your contributions
JavaScript is an imperative language with access to a wide range
of established and useful services like graphical canvases and event
handling of browser events. 
We want to express JavaScript in Haskell, adding use
of Haskell's static typing, and gaining access to JavaScript services
in the browser directly in Haskell.

In general, there are a number of ways of providing access to non-native services,
such as the JavaScript canvas.
\begin{enumerate}
\item A first approach is to provide, in Haskell, 
foreign function ``hooks'' to key JavaScript functionality.
Haskell already provides many similar hooks into the RTS,
so why not into the JavaScript engine?
For this to work efficiently, the compiler
needs to target JavaScript. There are already a
number is systems doing this~\cite{...}.
If executed well, this would be ideal,
there are shortcomings: many standard libraries
are not supported directly, the generated
code is not as efficiently executed as native Haskell,
and the compilers are still immature and incomplete.

\item An second approach is to keep the 
foreign function ``hooks'' to key JavaScript functionality,
but instead run Haskell as a server that JavaScript
and the browser interacts with.
Unfortunately, every JavaScript call becomes an expensive proposition: an RPC call
to a browser.
Though some straight-line calls can be batched together --
our own blank-canvas hackage package~\cite{..} was built on this idea --
the granularity of interaction through JavaScript call is just too fine for
this idea to scale well.

\item A first, alternative approach is to use Haskell to generate JavaScript from
an abstract syntax tree of the JavaScript code. There have
been a number of attempt to have DSLs that do the in other spaces,
and functional languages have good support for generating trees.
However, this approach works well for data-flow, for example
as use in Lava. When describing control-flow,
as would be typically in a JavaScript program,  writing such an AST always
feels forced, primarily because there is a mismatch between
bindings in the native language (Haskell) and the non-native
generated code (JavaScript variable names).

\end{enumerate}

This paper investigate the expansion of scope of the second option,
specifically adding binding to the Haskell code
that can be batch together and send to the JavaScript engine,
and then scaling the language to support larger examples.
Binding is done using regular Haskell monadic binding, and fits naturally
into what we expect from a monadic API. Until recently,
it was thought that it was impossible to use a regular
Haskell monad for this purpose. In a previous paper,
we show that such a construction is possible~\cite{..}
In this paper, we expand on this observation,
and show that this form of reification is useful in practice.

Further building on this capability, we also investigate providing
JavaScript control flow and function abstraction mechanisms
to the Haskell programmer interested in using the browser API.
Though for technical reasons we can not compile the transitional
pattern matching and let-binding to JavaScript without committing
to a full compiler Haskell to JavaScript compiler, both
control flow and function abstraction can be provided
with a small syntactical overhead.

With these three capabilities, a programmer can start programming
using the provided JavaScript API directly, and refine
their program to migrate more and more computation
from the server into the browser. In a real sense,
this blurs the distention between an RPC approach (2),
and a full Haskell to JavaScript compiler (1),
built using existing infrastructure, and not needing
the full compiler.




\begin{comment}
\section{Example Sunroof Program}
\label{sec:simple-example}

A simple drawing program, that we build up step by step.
Perhaps bouncing ball.
Perhaps drawing line.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Calling JavaScript from Haskell}
\label{sec:js-rpc}

From a programmers' point of view, calling JavaScript functions
appears straightforward. We, as a community know how to reflect an
API into Haskell, using the IO monad. Furthermore, objects in
the target API become handles in Haskell. 

As a first example, consider this simplified example of Sunroof code, and corresponding JavaScript.
\noindent
\begin{Code}
-- Haskell                          // JavaScript
ioCode :: IO ()
ioCode = send jsCode

jsCode :: JS ()
jsCode = do                        function jsCode() {
   name <- prompt "Your name?"       var v0 = prompt("Your name?"); 
   alert ("Your name: " <> name)     alert("Your name: " + v0); 
                                   }
\end{Code}%     
%\noindent 

Here, we use a new monad, the \Src{JS} monad, our JavaScript
analog to the \Src{IO} monad,
and an explicit \Src{send} command that sends the JavaScript to the browser.
This reversal of control, where the
server sends the clients commands is called the Ajax Comet~\cite{..},
or simply long polling.
This interface also bundles the \Src{prompt} and \Src{alert} commands
into one interaction transaction.
It is this flavor of interface we want to support in our Sunroof compiler
and web server.  

To make Sunroof a viable interface to JavaScript, we need to
resolve the following issues:
\begin{itemize}
\item JavaScript is an object-based, imperative, dynamically typed language.
Haskell is a pure, function-based, statically typed language.
Specifically how do these two worlds map onto each other.
In section~\ref{sec:object-model}, we discuss the chosen object model
and our JS monad.
%
\item We need to provide an imperative and therefor effectful interface,
including control flow, into our target language of JavaScript.
We do this via the \Src{JS} monad, which we discuss
in section~\ref{sec:js-monad}.
\item We choice to provide a way of defining functions
in Sunroof in a way that they are first-class functions
in JavaScript. This uses our \Src{JS} monad, and
is discussed in section~\ref{sec:functions-continuations}.
%
\item We need to provide a foreign function interface,
to allow us to call specific JavaScript-native functions,
like \Src{prompt} and \Src{alert}.
In section~\ref{sec:ffi} we present this interface.
%
\item Critically, we need to be able to compile our Sunroof DSL
into JavaScript. We look at this in section~\ref{sec:compiler}.
\item To enable the compiled code to dynamically interact with
a web browser, we provide an expansion of the \Src{send} idea above,
which we discuss in section~\ref{sec:server}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Sunroof Values}
\label{sec:object-model}

In the Sunroof DSL, like Haskell itself, we make a distinction between expressions and statements.

\subsection{Sunroof Expressions}

In JavaScript, there are a small number of core types, such as \Src{Object}, \Src{Array}, and \Src{String}.
In our JavaScript object model, there is a reflection of this family of core types, all prefixed with \Src{JS}.
There is support for booleans, strings, numbers, functions,
object and arrays, and other common programming structures.
The use of \Src{JSNumber}, rather than (say) \Src{Double},
explicitly reminds us of the enforced diminished capabilities of
being within an embedded language,
and all of the \Src{JS}-types are representable in our target language.
Table~\ref{tab:sunroof-types} enumerates major \Src{JS} types used in Sunroof.

\begin{table}[t]
\begin{center}
\begin{tabular}{r@{\quad}l@{\quad}l@{\quad}c}
\hline\rule{0pt}{12pt}%
  Constraint
  & Sunroof Type $\tau$
  & Haskell Analog \HaskellAnalog{$\tau$}
  & \Src{js} \\ \hline\rule{0pt}{12pt}%
  
  & \Src{()}       & \Src{()}     & $\checkmark$ \\
  & \Src{JSBool}   & \Src{Bool}   & $\checkmark$ \\
  & \Src{JSNumber} & \Src{Double} & $\checkmark$ \\
  & \Src{JSString} & \Src{String} & $\checkmark$ \\
  
  \Src{Sunroof $\alpha$}
  & \Src{JSArray $\alpha$} 
  & \Src{[$\HaskellAnalog{\alpha}$]}
  & \\
  
  \Src{SunroofKey $\alpha$}
  & \Src{JSMap $\alpha$ $\beta$}
  & \Src{Map $\HaskellAnalog{\alpha}$ $\HaskellAnalog{\beta}$}
  & \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSFunction $\alpha$ $\beta$ }
  & \Src{$\HaskellAnalog{\alpha}$ $\rightarrow$ JS$_\Src{A}$ $\HaskellAnalog{\beta}$} 
  & \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSMVar $\alpha$}
  & \Src{MVar $\HaskellAnalog{\alpha}$}
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSChan $\alpha$}
  & \Src{Chan $\HaskellAnalog{\alpha}$}
  & \\[2pt]
\hline
\end{tabular}
\end{center}
\caption{Sunroof types and their Haskell pendant.}
\label{tab:sunroof-types}
\end{table} 

The left-hand column of table~\ref{tab:sunroof-types} gives constraints,
implemented via Haskell type classes.
\begin{itemize}
\item  All our core types are brought together with the \Src{Sunroof} class.
If a type is an instance of \Src{Sunroof}, then that type can be realized inside JavaScript.
All the \Src{JS} types are instances of \Src{Sunroof}.

\item Instances of the \Src{SunroofArgument} class
are values that be passed to JavaScript functions and methods,
including tuples of values which are used for representing multi-argument 
function calls.
The asymmetry here is a reflection of the JavaScript
asymmetry inherited from C: you can pass multiple arguments
to a function, but only get a single thing back.

\item Finally, there is a third class, \Src{SunroofKey}, which is
is a JavaScript version of the Haskell \Src{Show} class,
but specifically for generating JavaScript object keys.
which are realized as JavaScript strings.
\end{itemize}

Using our \Src{JS}-types, we can build expressions using the traditional Haskell expression-build
mechanisms. \Src{JSNumber} is overloaded, and thus can be used directly for arithmetic.
\Src{JSBool} is an instance of the relevant classes in the hackage package \verb|boolean|.
Further, \Src{JSString} is a \Src{Monoid}~\cite{..}, which is only possible because JavaScript
strings are immutable values.

To help the conversion between classical Haskell values and Sunroof values,
we provide the overloaded function \Src{js}. The right-hand column of 
table~\ref{tab:sunroof-types} shows what types can be converted on the fly.
Putting the expression-building capability together, 
along with a show function called \Src{string}, we can write:
\begin{Code}
alert ("n =  " <> js (n :: Int) <> " n " <> string (m :: JSNumber))
\end{Code}
Here, \Src{n} is a Haskell \Src{Int}, and \Src{m} is a Sunroof number,
presumably the result of a previous computation. Given that we are 
bundling expressions to send to a browser for execution, \Src{n}
is a static value, and \Src{m} is a dynamic value, unobservable until inside our browser's execution.

One design decision in Sunroof is that we enforce a stronger typing than JavaScript itself would.
Specifically, there are restrictions on the type arguments of our container types,
like \Src{JSArray}. What can be seen from this is that we
enforce a Hindleyâ€“Milner style thinking to our containers,
which is distinct from JavaScript dynamic typing.
Some types involve
phantom types to give imposed type safety \cite{Cheney:03:FirstClassPhantomTypes}.
Thus, \Src{JSArray} is a restricted type of JavaScript Array, that, like Haskell,
support collections of the same type.

From experience with using Sunroof,
the mis-match in typing between Haskell and Sunroof/JavaScript
is not large problem in practice.
We also provide an explicit dynamic \Src{cast},
for use where the type-systems differ,
and both sides of the \Src{cast} are instances of \Src{Sunroof}.
\begin{Code}
cast :: (Sunroof a, Sunroof b) => a -> b
\end{Code}

\subsection{Sunroof Statements}

The building block of object-oriented programing is calling an object's method.
This is almost universally done using the dot (\Src{.}) operator. JavaScript, or target language, 
follows this trend, with the method-call syntax being as follows:
\begin{Code}
  // JavaScript
  object.method(a1,a2,a3,...,aN)
\end{Code}
For our Sunroof object model, we want to model this as close as possible.
We, by convention, have our method calls take the object as the {\em last\/} argument,
and use a monad, called the \Src{JS} monad, for the result because method calls are effectful.
\begin{Code}
// Shape of a Sunroof method
(SunroofArgument args, Sunroof res) => args -> (Object -> JS res)
\end{Code}
A neat way of writing method calls in Haskell is transcribing the JavaScript dot, which is already use
for both namespace resolution and function composition in Haskell, with the \Src{\#} combinator~\cite{Shields:01:Babel}.
The \Src{\#} combinator simply applies the second argument to the first (object) argument.
\begin{Code}
// Sunroof        
(#) :: a -> (a -> JS b) -> JS b
(#) obj act = act obj
\end{Code}

\noindent
This gives the follow fragment for a Sunroof call to \Src{method} on \Src{object}.
\begin{Code}
  object # method (a1,a2,a3,...,aN)
\end{Code}
In this way, JavaScript can be transliterated into Haskell where needed,
native JavaScript call idioms can be used,
while other Haskell abstraction mechanisms can be used for the interface that calls Sunroof code.

We piece together our Sunroof method calls using the Haskell support for monads.
\begin{Code}
  r1 <- object # method1 (a1,a2,a3,...,aN)
  r2 <- object # method2 (... can use r1 ...)
  ....
\end{Code} 
In this fragment, \Src{r1} is bound to the result of the \Src{method1} call,
and can be used as an argument to \Src{method2}.

Sometimes, a JavaScript API requires direct access to object attributes.
We do so using a typed \Src{JSSelector}.
\begin{Code}
label :: JSString -> JSSelector a
(!)   :: (Sunroof o, Sunroof a) => o -> JSSelector a -> a
(:=)  :: (Sunroof a, Sunroof o) => JSSelector a -> a -> (o -> JS t ())
\end{Code}
We can build a selector (\Src{label}), use a selector to access a attribute in a specific
object (\Src{!}), or update an attribute in a specific object (\Src{:=}).
The update is in our object-normal-form, that is the object is the final argument.
Sunroof is, in essence, a strict functional language, with monads for effect.
We choose to support direct (non-monadic) reading of attributes, but
all writing of an 
This is a design decision we may return to in the future.

The net effect is that assignments to fields can be neatly expressed,
in a syntax is this close to JavaScript itself. Our HTML5 canvas library,
build on top of Sunroof primitives, allows the following statement:
\begin{Code}
  c # color := "red"
\end{Code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Threading Models}
\label{sec:threading-models}

JavaScript uses a callback-centric model of computation. There
is no concurrency, only a single central loop that executes
callbacks as non-blocking computations when events occur.

In contrast, Haskell has robust concurrency and wide-spread 
abstractions for synchronization, e.g. \Src{MVar}s and \Src{Chan}s
\cite{Jones:96:ConcurrentHaskell}.
So the question arises: do we generate atomic JavaScript code, 
and keep the callback centric model, or generate JavaScript
using CPS \cite{Claessen:99:PoorMansConcurrencyMonad}, 
and allow for blocking primitives and
cooperative concurrency. The latter, though more powerful, 
precluded using the compiler to generate
code that can be cleanly called from native JavaScript.
In our earlier work~\cite{...}, we prototyped both models
of computation, and observed that both choices had poor consequences
when mapping Haskell to JavaScript.

When scaling up Sunroof, we decided to explicitly support both,
and make both first-class threading {\em strategies\/} in Sunroof.
This means that the programmer can choose what model fits
the idiom being coded.

In terms of user-interface, we parameterize the \JS-monad
with a phantom type that represents the threading model used, 
with \Src{A} for \Src{A}tomic,
and \Src{B} for \Src{B}locking threads. 
Atomic threads are classical JavaScript computations that
cannot be interrupted and actively use the callback
mechanism. Blocking threads can
support suspending operations and cooperative concurrency
abstractions as known from Haskell. By using phantom
types, we can express the necessary
restrictions on specific combinators, as well
as provide combinators to allow both types of
threads to cooperate.

The blocking model hides the callback mechanism behind abstractions.
This implies that every atomic computation can be converted into 
a blocking computation. \Src{liftJS} achieves this.
\begin{Code}
liftJS :: Sunroof a => JS A a -> JS t a
\end{Code}

When suspending, we register our current
continuation as a callback to resume later. This gives other 
threads (registered continuations) a chance to run.
Of course, this model depends on cooperation between the threads,
because a not terminating or suspending thread will keep others from running.

There are three main primitives for the blocking model:
\begin{Code}
forkJS      :: SunroofThread t1 => JS t1 () -> JS t2 ()
threadDelay :: JSNumber -> JS B ()
yield       :: JS B ()
\end{Code}
They can all be seen as analogues of their \IO~counterparts.
\Src{forkJS} resembles \Src{forkIO}.
It registers the given computation as a callback. 
\Src{yield} suspends the current thread by 
registering the current continuation as a callback,
giving other threads time to run.
\Src{threadDelay} is a form of \Src{yield} that sets 
the callback to be called after a certain amount of time.
We rely on the JavaScript function \Src{window.setTimeout} 
\cite{whatwg:timers} to register our callbacks.

The class \Src{SunroofThread} offers functions to retrieve the 
current threading model (\Src{evalStyle}) and to create a possible
blocking computation (\Src{blockableJS}).
\begin{Code}
class SunroofThread (t :: T) where
  evalStyle   :: ThreadProxy t -> T
  blockableJS :: (Sunroof a) => JS t a -> JS B a
\end{Code}
Based on these primitive combinators, we also offer a Sunroof 
version of \Src{MVar} and \Src{Chan}: \Src{JSMVar} and \Src{JSChan}.
\begin{Code}
newMVar      :: (SunroofArgument a) => a -> JS t (JSMVar a)
newEmptyMVar :: (SunroofArgument a) => JS t (JSMVar a)
putMVar      :: (SunroofArgument a) => a -> JSMVar a -> JS B ()
takeMVar     :: (SunroofArgument a) => JSMVar a -> JS B a

newChan   :: (SunroofArgument a) => JS t (JSChan a)
writeChan :: (SunroofArgument a) => a -> JSChan a -> JS t ()
readChan  :: (SunroofArgument a) => JSChan a -> JS B a
\end{Code}
Note that the types reflect if a specific operation can block.
For example, \Src{writeChan} can never block, so you can use either threading model,
but \Src{readChan} may block, so uses the \Src{B} threading model.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\input{sections/js-monad}

%\input{sections/functions-continuations}
%\input{sections/threading-model}

%\input{sections/ffi}
%

%\input{sections/compiler}

%\input{sections/server}

%\input{sections/extended-example}

%\TODO{Should we add the discussion why we choose a deep embedding somewhere?}

%\input{sections/related-work}

%\input{sections/conclusion-discussion}

\section{Acknowledgment}

We want to thank Conal Elliott for his support in adapting 
the Boolean package \cite{project:boolean} and helping us to
extend it with support for deeply embedded numbers.

%
% ---- Bibliography ----
%
\bibliographystyle{splncs03}
\bibliography{sunroof}
\vspace{-0.5cm} % THIS SAVED MY LIFE

\end{document}

% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{amsfonts}

\newcommand{\SunroofAnalog}[1]{#1\ensuremath{_\downarrow}}
\newcommand{\HaskellAnalog}[1]{#1\ensuremath{_\uparrow}}


\begin{document}
\newcommand{\NOTE}[1]{{\Large\textbf{NOTE:}\ #1}}
\newcommand{\Src}[1]{{\sf #1}}
%
\title{Sunroof}
%
\titlerunning{Sunroof}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Jan Bracker \and Andy Gill}
%
\authorrunning{Jan Bracker \and Andy Gill} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Jan Bracker, Andy Gill}
%
\institute{%
Information Technology and Telecommunication Center\\
Department of Electrical Engineering and Computer Science\\
The University of Kansas\\
2335 Irving Hill Road\\
Lawrence, KS 66045\\
   {\{???\}@ku.edu}%
}

\maketitle              % typeset the title of the contribution

\begin{abstract}        
        
Sunroof is a Domain Specific Language (DSL) for generating JavaScript.
Sunroof is build on top of the JS-monad, which, like the Haskell IO-monad, allows 
read and write access to external resources, but specifically JavaScript
resources. As such, Sunroof is primarily a feature-rich foreign
function API to the browser's JavaScript engine, and all the browser-specific
functionality, like HTML-based rendering, event handling, and 
drawing to the HTML5 canvas. 

In this paper, we give the design and implementation of Sunroof, a 
deeply embedded Haskell-hosted DSL.
This makes it easy to use Haskell abstractions for larger Javascript
applications without obscuring the produced Javascript on the Haskell
level. 
Furthermore, Sunroof offers two threading models for 
building on top Javascript, atomic and blocking threads.
This allows full access to Javascript APIs, but
using Haskell concurrency patterns, like MVars and Channels.
In combination with a small web services package, like Scotty,
Sunroof offers a great platform to build interactive web applications,
giving the ability to interleave Haskell and Javascript computations
with each other as needed.
\keywords{Haskell DSL, JavaScript, Web Technologies, Cloud Computing}
\end{abstract}
%
\section{Introduction}

An essential part of most modern web applications is Javascript.
It opens various possibilities to create browser based applications.
Examples for this development are Googlemail or Facebook.
These applications rely on Javascript heavily. What makes this 
development possible are the fast interpreters available in all
major browsers. Developing applications inside the browser has
the advantage of being independent from the underlying hard- and
software platform. The problem is shifted from the actual machine
to the browser. Also modern web technologies like HTML5 and CSS
give easy to use tools for developing user interfaces for the
mentioned application. They are standardized and improved over year 
now. 

Yet, writing actual code in Javascript can be tedious and error prone 
due to its not-statically typed nature. Also the object-oriented
paradigm and the callback mechanism used instead of proper multi-threading 
can be a stumbling block for veteran Haskell programmers. Especially when
facing the lack of type safety.

To make the power of Javascript available to Haskell programmers 
we developed Sunroof. It enables Haskell programmers to write
Javascript using Haskell through a deep embedding. This 
approach has several advantages:

\begin{description}
\item[Type Safety:] Sunroof provides custom types for all major Javascript
types. Thus it gives type safety similar to what we are used to from 
normal Haskell programs when writing Javascript.
\item[Paradigms \& Patterns:] As a Haskell EDSL Sunroof follows functional programming 
paradigms and principals. It is possible to reuse common combinators and 
patterns in Sunroof.
\item[Similarity:] At the same time Sunroof offers a API for Javascript 
that allows to translate Javascript into Sunroof code easily.
\item[Optimization:] Due to Sunroofs deep embedded nature it is able
to apply optimizations like expression sharing when compiling to Javascript.
\end{description}

\NOTE{This might be a bit to enthusiastic.}

We want to use the JavaScript API. Fast interpreters,
running in a browser advantage, 

We do not want to program in Javascript.

\section{Example Sunroof Program}

A simple drawing program, that we build up step by step.
Perhaps bouncing ball.
Perhaps drawing line.

\section{Background}

Choices when compiling to Javascript
 * Port a compiler to JavaScript - issues, mismatching API, other efforts.
 * Provide an FFI - back and forward cost.
 * Compile a custom, cut down FP language. - example
 * DSL, restrictive, syntactically, how do we handle binding?

We use monad reification.
 * binding in Haskell becomes binding in reified language.
 * Feels like a native monad, cf STM.
 * Can build abstractions on top of this.

Design objectives and contributions.
\begin{itemize}
\item 
Specifically, we want to explore how similar to a native Haskell monad,
like the IO or STM monads, can we make the JS monad feel to Sunroof users.
\item We want to reflect objects. (easy)

\item We want also investigate the relationship between Haskell functions
and JavaScript functions. In particular, there is an isomorphism
between monadic functions in Haskell, with the type \verb|a -> JS b|,
and JavaScript functions, which we will notate using \verb|JSFunction|.
This relationship is more interesting than a Haskell synonym;
it reflects the reification options for capturing functions.
\end{itemize}

 
Compiling
 * If we transliterate, we have straight line code, can not pause.
    (Wait for Mvar, for example)
 * If we CPS translate, we can use continuations to capture the
   notion of a paused thread. Works well.
   Problems:
     * Can not translate functions, how do they get there return value
     * (Assumes straight line code.)
     * Also, the code becomes unreadable to anyone except a die-hard 
       compiler freak.
 
Choice:
 * We support both!
 * Phantom argument to JS
 * A = Atomic, B = Blockable.

Highlights

 * function / continuation
 * implementing wait \& fork

\begin{table}
\caption{Major instances of the Sunroof class}
\begin{center}
\begin{tabular}{r@{\quad}l@{\quad}l@{\quad}c}
\hline\rule{0pt}{12pt}%
  Constraint
  & Sunroof Type $\tau$
  & Haskell Analog \HaskellAnalog{$\tau$}
  & \Src{js} \\ \hline\rule{0pt}{12pt}%
  
  & \Src{()}       & \Src{()}     & $\checkmark$ \\
  & \Src{JSBool}   & \Src{Bool}   & $\checkmark$ \\
  & \Src{JSNumber} & \Src{Double} & $\checkmark$ \\
  & \Src{JSString} & \Src{String} & $\checkmark$ \\
  
  \Src{Sunroof $\alpha$}
  & \Src{JSArray $\alpha$} 
  & \Src{[$\HaskellAnalog{\alpha}$]}
  & $\checkmark$ \\
  
  & \Src{JSMap JSString $\beta$}
  & \Src{Map String $\HaskellAnalog{\beta}$}
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSFunction $\alpha$ $\beta$ }
  & \Src{$\HaskellAnalog{\alpha}$ $\rightarrow$ JS$_\Src{A}$ $\HaskellAnalog{\beta}$} 
  & $\checkmark$ \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSMVar $\alpha$}
  & \Src{MVar $\HaskellAnalog{\alpha}$}
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSChan $\alpha$}
  & \Src{Chan $\HaskellAnalog{\alpha}$}
  & \\[2pt]
\hline
\end{tabular}
\end{center}
\end{table} 

\begin{table}
\caption{Reifying and calling JavaScript functions}
\begin{center}
\begin{tabular}{r@{\quad}c@{\quad}c@{\quad}c@{\quad}c}
\hline\rule{0pt}{12pt}%

                & Monadic Function      & Reification   & Object in     & Invocation\\
                & in Haskell            & Function      & JavaScript    & Function\\
\hline\rule{0pt}{12pt}%
  Functions
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{A}~\beta$
  & \Src{function}
  & \Src{JSFunction}~$\alpha~\beta$
  & \Src{apply} \\
  Continuations
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{B}~\Src{()}$
  & \Src{continuation}
  & \Src{JSContinuation}~$\alpha$
  & \Src{goto}\\
\hline
\end{tabular}
\end{center}
\end{table} 

Up to this point, Sunroof is academically interesting, but in a real sense
we are writing JavaScript using Haskell syntax, so why not just write
JavaScript? There are three things we have bought by using our DSL.
\begin{itemize}
\item Typing -- We have a simple monomorphic type system that helps development of Sunroof code.
\item Haskell Abstractions --
\item Dynamic Generation -- 
\end{itemize}

\section{Haskell Abstraction}

About MVar and Chan.

\section{Sunroof Server}



\section{Case Study - hp2ps}

hp2ps is a tools for graphically displaying GHC heap profiles.
The tools history is that is was written by Malcolm Wallace while working
for the York ??? group, in 1992. The tool works as a simple filter,
reading hp files, and outputting postscript, with the postscript
doing the heavy lifting of the graphical rendering.

-----------

Talk about Active, but not in any details.


 It was written
in C by 

\section{Related Work}

To JavaScript in JavaScript (CoffeeScript).

Haskell to JavaScript

Other Deep embeddings.

%
% ---- Bibliography ----
%

\end{document}

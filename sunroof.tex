% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\begin{document}
\newcommand{\NOTE}[1]{{\Large\textbf{NOTE:}\ #1}}
%
\title{Sunroof}
%
\titlerunning{Sunroof}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Jan Bracker \and Andy Gill}
%
\authorrunning{Jan Bracker \and Andy Gill} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Jan Bracker, Andy Gill}
%
\institute{%
Information Technology and Telecommunication Center\\
Department of Electrical Engineering and Computer Science\\
The University of Kansas\\
2335 Irving Hill Road\\
Lawrence, KS 66045\\
   {\{???\}@ku.edu}%
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}

An essential part of most modern web applications is Javascript.
It opens various possibilities to create browser based applications.
Examples for this development are Googlemail or Facebook.
These applications rely on Javascript heavily. What makes this 
development possible are the fast interpreters available in all
major browsers. Developing applications inside the browser has
the advantage of being independent from the underlying hard- and
software platform. The problem is shifted from the actual machine
to the browser. Also modern web technologies like HTML5 and CSS
give easy to use tools for developing user interfaces for the
mentioned application. They are standardized and improved over year 
now. 

Yet, writing actual code in Javascript can be tedious and error prone 
due to its not-statically typed nature. Also the object-oriented
paradigm and the callback mechanism used instead of proper multi-threading 
can be a stumbling block for veteran Haskell programmers. Especially when
facing the lack of type safety.

To make the power of Javascript available to Haskell programmers 
we developed Sunroof. It enables Haskell programmers to write
Javascript using Haskell through a deep embedding. This 
approach has several advantages:

\begin{description}
\item[Type Safety:] Sunroof provides custom types for all major Javascript
types. Thus it gives type safety similar to what we are used to from 
normal Haskell programs when writing Javascript.
\item[Paradigms \& Patterns:] As a Haskell EDSL Sunroof follows functional programming 
paradigms and principals. It is possible to reuse common combinators and 
patterns in Sunroof.
\item[Similarity:] At the same time Sunroof offers a API for Javascript 
that allows to translate Javascript into Sunroof code easily.
\item[Optimization:] Due to Sunroofs deep embedded nature it is able
to apply optimizations like expression sharing when compiling to Javascript.
\end{description}

\NOTE{This might be a bit to enthusiastic.}

We want to use the JavaScript API. Fast interpreters,
running in a browser advantage, 

We do not want to program in Javascript.

Example: hp2ps?

\section{Background}

Choices when compiling to Javascript
 * Port a compiler to JavaScript - issues, mismatching API
 * Provide an FFI - back and forward cost.
 * Compile a custom, cut down FP language. - example
 * DSL, restrictive, syntactically, how do we handle binding?

We use monad reification.
 * binding in Haskell becomes binding in reified language.
 * Feels like a native monad, cf STM.
 * Can build abstractions on top of this.

PUSH: how like a native Haskell monad can we make the JS monad feel?

PUSH: isomorphism between 
 
   a -> JS b  

and

   JSFunction a b
 
Compiling
 * If we transliterate, we have straight line code, can not pause.
    (Wait for Mvar, for example)
 * If we CPS translate, we can use continuations to capture the
   notion of a paused thread. Works well.
   Problems:
     * Can not translate functions, how do they get there return value
     * (Assumes straight line code.)
     * Also, the code becomes unreadable to anyone except a die-hard 
       compiler freak.
 
Choice:
 * We support both!
 * Phantom argument to JS
 * A = Atomic, B = Blockable.

%
% ---- Bibliography ----
%

\end{document}

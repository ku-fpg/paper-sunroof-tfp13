 
\section{The JavaScript Monad}
\label{sec:js-monad}

JavaScript is an imperative language with access to a wide range
of established and useful services, like graphical canvases and event
handling. JavaScript as a language also provides features that are
traditionally associated with functional languages, like first-class 
functions. We want to express JavaScript in Haskell, adding use
of Haskell's static typing, and gaining access to JavaScript services.
And we do so using the transitional functional programming 
mechanism for being imperative, a monad~\cite{Moggi:91:ComputationMonads}.

The \JS-monad is the monad of JavaScript effects, as is an almost
exact analog for the Haskell \IO-monad, except there
is an extra phantom argument~\cite{Leijen:99:Phantom} that we will return
to shortly.  Figure~\ref{fig:code-example} gives a first example
of the \JS-monad in use with the generated JavaScript.

Inside this simple example is a challenging problem -- where does
\Src{v0} come from? The bind inside the monadic \Src{do} is
unconstrained:
\begin{verbatim}
(>>=) :: JS t a -> (a -> JS t b) -> JS t b
\end{verbatim}
What we want is:
\begin{verbatim}
(>>=) :: (Sunroof a) => JS t a -> (a -> JS t b) -> JS t b
\end{verbatim}
Where \Src{Sunroof} constrains the bind to
arguments for which we can generate a JavaScript variable.
Counterintuitively, 
it turns out that a specific form of normalization allows 
the ``\Src{a}'' type to be constrained and the bind to 
be an instance of the standard monad class~\cite{Sculthorpe:13:ConstrainedMonads}.
Through this keyhole of {\em monadic reification\/},
the entire Sunroof language is realized.

\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

Basic Idea
\begin{itemize}
\item Put the current stuff into the introduction does not belong here
\item \JS-monad is analog of \IO-monad
\item Monad used to model sequences of statements with side-effect in 
JavaScript \cite{Moggi:91:ComputationMonads}
\item binding in Haskell becomes binding in JavaScript (more about this in section \ref{sec:compiler})
\item There also is a expression level (discussed in section \ref{sec:object-model})
\item Feels like a native monad, cf STM.
\item Can build abstractions on top of this.
\end{itemize}
Implementation
\begin{itemize}
\item Problems when using monad: Types need to be constrained to work
\item We use monad reification \cite{Apfelmus:10:Operational,Hackage:10:Operational}
\item But \JS-monad is a little bit more complicated
\item Show \JS-constructor: \Src{JS :: ((a -> Program (JSI t) ()) -> Program (JSI t) ()) -> JS t a}
\item Whats going on here?
\item \JS-monad is a continuation monad on the \Src{Program} type from operational
\item Monad instance is the standard implementation for a continuation 
monad (TODO: cite for continuation monad)
\item This is necessary, because we want to support different threading styles 
(discussed in chapter \ref{sec:threading-models})
\item For now think of it as producing a sequence/list of abstract instructions: \JSI
\item Look at the \JSI\ type and introduce it
\item Explain how it is a high-level representation of JavaScript
\item TODO: Look at all constructors? Or only the interesting ones (marked with "!")?
  \begin{itemize}
  \item ! Function and continuation are technically the same, but different instructions
  \item ! Reason for this is TODO?
  \item ! Why are there two different assignments?
  \item ! One is assignment to variable, other is assignment to the field of an object
  \item ! Eval, this looks weird. Forces evaluation and binding to a variable.
  \item ! Otherwise, we would use macro semantics in many places.
  \item ! Fix is provided to be able to write recursive functions
  \item ! Why isn't that possible without fix? problem boils down to 
        not observable sharing between statements and bindings. This
        leads compiler into infinite loops.
  \item Select selects a field
  \item Delete remove a field
  \item Invoke call a function/method
  \item Return for return of a function
  \item Comment writes some comment, helps for debugging
  \end{itemize}

\end{itemize}





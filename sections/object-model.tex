 
\section{JavaScript Object Model}
\label{sec:object-model}

In our JavaScript object model, there are a family of core types, all prefixed with JS.
Each one corresponds to a specific JavaScript type.
There is support for booleans, strings, numbers, functions,
object and arrays, and other common programming structures.
The use of \Src{JSNumber}, rather than (say) \Src{Double},
explicitly reminds us of the enforced diminished capabilities of
being within an embedded language.
All of the \Src{JS}-types are representable in our target language.

Using the \Src{JS}-types, we can give types to \Src{alert} and \Src{prompt}.
\begin{Code}
alert :: JSString -> JS ()
prompt :: JSString -> JS String
\end{Code}
In reality, JavaScript overloads \Src{alert} and \Src{prompt},
so this is providing type-safe access to a sub-set of what
alert can do.

There are two primary Haskell classes represent things that can
be passed to and returned from JavaScript functions.
Instances of the \Src{Sunroof} class 
are values that are returned from JavaScript functions,
and represent all basic JavaScript values.
Instances of the \Src{SunroofArgument} class
are values that be passed to JavaScript functions,
including tuples of values which are used for representing multi-argument 
function calls.
The asymmetry here is a reflection of the JavaScript
asymmetry inherited from C: you can pass multiple arguments
to a function, but only get a single thing back.
Finally, there is a third class, \Src{SunroofKey}, which is
is a JavaScript version of the Haskell \Src{Show} class,
but specifically for generating JavaScript object keys.

Table~\ref{tab:sunroof-types} enumerates major \Src{JS} types,
and any restrictions on the type arguments enforced by containers,
like \Src{JSArray}. What can be seen from this is that we
enforce a Hindleyâ€“Milner style thinking to our containers,
which is distinct from JavaScript dynamic typing.
The thinking in Sunroof is that we enforce a stronger typing
than JavaScript itself would, but also provide an explicit \Src{cast},
for use where the type-systems differ.
\begin{Code}
cast :: (Sunroof a, Sunroof b) => a -> b
\end{Code}
From experience with using Sunroof,
the mis-match in typing between Haskell and Sunroof/JavaScript
is not large problem in practice,
many programs translate from Sunroof to JavaScript
maintaining the stronger typing.
Casts are typically used in the same way \Src{show} is used
to map numbers to strings in the context of building
string values that contain numbers. We also provide
some variants of \Src{cast} with more specific types
to help alleviate some of the dynamic typing.
Overall, we maintain the mantra of ``static type where you can,
use a cast if you need it''.

\CURSOR{}

{\em About how we provide the API in Haskell}

Transliterations.

Key functions.

Key types.



One goal of Sunroof is to use Haskell's type system to
increase the confidence of the expressed JavaScript.
At the same time we cannot characterize 
all different types of objects in JavaScript, since 
users can create their own objects. Thus our 
system to type JavaScript needs to be extensible.

Our solution is to provide a basic \Src{Expr}ession
language to construct JavaScript expressions 
that have no associated type information. Simplified slightly, we have:
\begin{Code}
data Expr 
  = Lit String        -- Precompiled (atomic) JavaScript literal
  | Var Id            -- Variable
  | Apply Expr [Expr] -- Function application
  ...
\end{Code}
In reality, we abstract \Src{Expr} over the recursive type,
to facilitate the usage of observable sharing \cite{Gill:09:TypeSafeReification}
and allow sub-expression computations to be shared.

This core expression type 
is then wrapped to represent a more specific type. 
Each of these wrappers implements the \Src{Sunroof} type class.
\begin{Code}
class SunroofArgument a => Sunroof a where
  box   :: Expr -> a
  unbox :: a -> Expr
  ...
\end{Code}
It marks these types as possible values in JavaScript.
The \Src{SunroofArgument} prerequisite permits them 
to be function arguments (\SecRef{sec:functions-continuations}).

An example of this is \Src{JSString}, the representation
of JavaScript strings.
\begin{Code}
data JSString = JSString Expr
instance Sunroof JSString where
  box                = JSString
  unbox (JSString e) = e
\end{Code}
But what do we gain through a wrapper? We can
provide specific functionality for each distinct type.
Our example type \Src{JSString} has a \Src{Monoid} and an 
\Src{IsString} instance that are not provided for other 
wrappers, e.g. \Src{JSBool} or \Src{JSNumber}.
This is the same approach used by
Svenningsson \cite{Svenningsson:12:CombiningEmbedding}.

\TabRef{tab:sunroof-types} gives a summary of the 
prominent Sunroof types. Some types involve 
phantom types to give more type safety \cite{Cheney:03:FirstClassPhantomTypes}.
\begin{table}
\begin{center}
\begin{tabular}{r@{\quad}l@{\quad}l@{\quad}c}
\hline\rule{0pt}{12pt}%
  Constraint
  & Sunroof Type $\tau$
  & Haskell Analog \HaskellAnalog{$\tau$}
  & \Src{js} \\ \hline\rule{0pt}{12pt}%
  
  & \Src{()}       & \Src{()}     & $\checkmark$ \\
  & \Src{JSBool}   & \Src{Bool}   & $\checkmark$ \\
  & \Src{JSNumber} & \Src{Double} & $\checkmark$ \\
  & \Src{JSString} & \Src{String} & $\checkmark$ \\
  
  \Src{Sunroof $\alpha$}
  & \Src{JSArray $\alpha$} 
  & \Src{[$\HaskellAnalog{\alpha}$]}
  & \\
  
  \Src{SunroofKey $\alpha$}
  & \Src{JSMap $\alpha$ $\beta$}
  & \Src{Map $\HaskellAnalog{\alpha}$ $\HaskellAnalog{\beta}$}
  & \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSFunction $\alpha$ $\beta$ }
  & \Src{$\HaskellAnalog{\alpha}$ $\rightarrow$ JS$_\Src{A}$ $\HaskellAnalog{\beta}$} 
  & \\
  \Src{Sunroof $\beta$} \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSMVar $\alpha$}
  & \Src{MVar $\HaskellAnalog{\alpha}$}
  & \\
  
  \Src{SunroofArgument $\alpha$}
  & \Src{JSChan $\alpha$}
  & \Src{Chan $\HaskellAnalog{\alpha}$}
  & \\[2pt]
\hline
\end{tabular}
\end{center}
\caption{Sunroof types and their Haskell pendant.}
\label{tab:sunroof-types}
\end{table} 
The smooth embedding of booleans and numbers is done through
the Boolean package \cite{project:boolean}.

\TabRef{tab:sunroof-types} shows that most basic 
Haskell types have counterparts in
Sunroof. To convert Haskell values into their 
counterparts, we provide the \Src{SunroofValue} class.
\begin{Code}
class SunroofValue a where
  type ValueOf a :: *
  js :: (Sunroof (ValueOf a)) => a -> ValueOf a
\end{Code}
The type function
\Src{ValueOf} \cite{Chakravarty:05:AssociatedTypeSynonyms} 
provides the corresponding Sunroof type.
\Src{js} converts a value from Haskell to Sunroof. 
By design \Src{SunroofValue} 
only provides instances for values that can be converted in a pure
manner. Some types in JavaScript are referentially 
transparent according to \Src{==}, while others, like general objects,
are not. As an example, if you call \Src{new Object()}, twice you get two 
equivalent empty objects, but when compared by \Src{==} they are different. They
are not identical, because in this case reference equality is checked
instead of value equality. We call this observable allocation and handle 
it as a side-effect which may only occur in the \JS-monad. 

%This approach ensures to bind a new value to a variable,
%instead of creating copies of that value everywhere
%it is used. This resolves some unwanted macro behavior 
%of Sunroof.

% JSTuple is not a major selling point nor is it essential to sunroof.
\begin{comment}
Sunroof also offers the ability to work with record like data structures.
For this purpose Sunroof offers the \Src{JSTuple} type class.
\begin{Code}
class Sunroof o => JSTuple o where
  type Internals o
  match :: (Sunroof o) => o -> Internals o
  tuple :: Internals o -> JS t o
\end{Code}
If you have a record of Sunroof data that you want to
encode as a JavaScript object you can provide this ability 
by implementing \Src{JSTuple}. The \Src{Internals} type function
delivers your record type. Encoding that record as a \Src{Sunroof}
value is done through \Src{tuple}. 
Because of the observable allocation issue, we have to be 
inside the \JS-monad to do this.
Decomposing the encoding is done with \Src{match}. Because the
\Src{JSTuple} idiom is meant to represent immutable data structures, this 
can be done in a pure manner although there are ways to mutate 
values referenced by the decomposed record, since they are only 
references to the actual data in JavaScript.
\end{comment}

\begin{comment}
\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

General Objects Types and Expressions
\begin{itemize}
\item We want to use Haskell's type system to give use type safety in JavaScript/Sunroof.
\item JavaScript is untyped / dynamically typed \TODO{what is it actually? cite/reference?}
\item We can not represent all types in JavaScript
\item We have to give a way to add types later on
\item Use approach from \cite{Svenningsson:12:CombiningEmbedding}
\item There is a core expression language that is used to describe how and expression is built
\item We wrap that core type into wrappers
\item Introduce \Src{Sunroof} to mark wrappers
\item Wrappers have specific functionality for certain type
\item Wrappers can have phantom type to give more type safety
\item Example \Src{JSString} and \Src{JSArray a}
\item Maybe go through example type like \Src{JSString} or \Src{()}.
\item Unavoidable need to cast types some times: \Src{cast}
\item Adding a new type can be done mechanically: Template Haskell
\end{itemize}
Haskell to Sunroof conversion
\begin{itemize}
\item Many haskell types have equivalent or similar types in JavaScript
\item So we offer \Src{SunroofValue}; It connects a Haskell value with 
its JavaScript companion through a type function (cite type functions)
and gives a function to convert: \Src{js}
\item Introduce \Src{SunroofValue}
\item Conversion is pure for most types since atomic values 
are created when converting.
\item Exception \Src{JSFunction}, same reason as for \Src{JSTuple} and \Src{tuple}
\item Show table with types as an overview. Small comment paragraph about table.
\item \Src{JSArray} not possible because of conflicts with \Src{String}
instance (minor point); also issue of mutability of arrays; observable 
allocation issue like with \Src{JSTuple}.
\item Forward reference to \SecRef{sec:threading-models} for \Src{JSMVar}
and \Src{JSChan}
\end{itemize}
JSTuple and records in JS
\begin{itemize}
\item Design decision: We do not want to introduce internal
structure for types. (Tuples aren't JS types)
\item \Src{JSTuple} exists to introduce types with custom structure
\item Introduce \Src{JSTuple}
\item manages composition and decomposition of custom types.
\item Meant to codify immutable records in JavaScript
\item They can only be changed
by decomposing them into Haskell and recreating a new structure
with other values.
\item Useful to manage more complex data structures in JavaScript.
\item Decomposition is pure operation: \Src{match}
\item Justification lies in the fact that they are meant to be 
immutable. Although there are possibilities to break this.
\item Composition is monadic effect: \Src{tuple}
\item It captures observable allocation and ensures that a reference to the
allocated value is created and used afterwards.
\item If it was not monadic the let binding would be like a macro
that reallocated the same object at each point. This 
is not desired behavior in most use-cases
\end{itemize}
\end{comment}







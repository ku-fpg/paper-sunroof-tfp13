 
\section{The Sunroof Compiler}
\label{sec:compiler}

Given the language, and monadic-reification, how do we compile this language?
Figure \ref{fig:structure} shows how Sunroof is structured.

\Figure%
{fig:structure}%
{figures/sunroof-structure.pdf}%
{The structure of Sunroof.}

Through the \JS-monad we produce a \Src{Program (JSI t) ()} instance. We 
translate such a program into a list of statements (\Src{Stmt}) by matching over 
the \JSI constructors.
\begin{verbatim}
data Stmt 
  = AssignStmt Rhs Expr       -- Assignment
  | DeleteStmt Expr           -- Delete reference
  | ExprStmt Expr             -- Expression as statement
  | ReturnStmt Expr           -- Return statement
  | IfStmt Expr [Stmt] [Stmt] -- If-Then-Else statement
  | WhileStmt Expr [Stmt]     -- While loop
  | CommentStmt String        -- Comment
\end{verbatim}
The constructors of \Src{Stmt} are straight forward and
directly represent the different statements one can write
in JavaScript.

To get a feeling of what is happening here, we will have a closer
look to how two of the \JSI instructions are compiled. First
lets have a closer look how branches are compiled.
\begin{verbatim}
compile :: Program (JSI t) () -> CompM [Stmt]
compile = eval . view
  where
    eval :: ProgramView (JSI t) () -> CompM [Stmt]
    eval (JS_Branch b c1 c2 :>>= k) = 
      case evalStyle (ThreadProxy :: ThreadProxy t) of
        A -> do
          (src0, res0) <- compileExpr (unbox b)
          res :: a <- jsValue
          let bindResults :: a -> JS t ()
              bindResults res' =
                sequence_ [ single $ JS_Assign_ v (box $ e :: JSObject)
                          | (Var v, e) <- jsArgs res `zip` jsArgs res'
                          ]
          src1 <- compile $ extractProgramJS bindResults c1
          src2 <- compile $ extractProgramJS bindResults c2
          rest <- compile (k res)
          return (src0 ++ [ IfStmt res0 src1 src2 ] ++ rest)
        B -> do
          fn_e <- compileContinuation 
            (\ a -> blockableJS $ JS $ \ k2 -> k a >>= k2)
          fn           <- newVar
          (src0, res0) <- compileExpr (unbox b)
          src1 <- compile $ extractProgramJS (apply (var fn)) c1
          src2 <- compile $ extractProgramJS (apply (var fn)) c2
          return ( [mkVarStmt fn fn_e] ++ src0 ++ [ IfStmt res0 src1 src2 ])
\end{verbatim}
\TODO This brings up more questions then it answers.


\begin{comment}
Given the language, and monadic-reification, how do we compile this language?
Figure \ref{fig:structure} shows how Sunroof is structured.
On the lowest level we provide an untyped expression language \Src{Expr}
that describes JavaScript expressions. 
To provide type safety when using Sunroof we create
wrappers for each type we want to represent, e.g. \Src{JSNumber} or \Src{JSString}.
The \Src{Sunroof} type class provides an 
interface to create wrapped and unwrapped
instances of our expressions. Based on the wrappers we can provide 
operations specific to a certain type, e.g. a \Src{Num} instance
for \Src{JSNumber} or a \Src{Monoid} instance for \Src{JSString}.



This technique enables us to utilize  Haskells type system when writing JavaScript
and offers an easy way to add new types when needed~\cite{Svenningsson:12:CombiningEmbedding}.
By using phantom types we can also provide more advanced types,
like \Src{JSArray a}.

The next layer provides JavaScript instructions through the type \JSI.
They represents abstract statements. While expressions and values
represented with type wrappers are assumed to be free of side-effects,
the instructions model side-effects in JavaScript. Examples for Instructions
are assignment of an attribute or the application of a function.
\begin{verbatim}
data JSI :: T -> * -> * where
  JS_Assign :: (...) => JSSelector a -> a -> JSObject -> JSI t ()
  JS_Invoke :: (...) => a -> JSFunction a r -> JSI t r
  JS_Branch :: (...) => bool -> JS t a -> JS t a  -> JSI t a
  ...
\end{verbatim}
The \JS-monad with its combinators builds a sequence of 
\JSI{}nstructions through the operational
package~\cite{Hackage:10:Operational,Apfelmus:10:Operational}.
All constraints required on instructions are introduced by their 
constructors.
As mentioned earlier the \JS-monad comes in two threading flavors, 
parameterized using a phantom type.
Internally the \JS-monad is implemented using CPS on the 
underlying \Src{Program} type from Operational. 
\begin{verbatim}
data JS :: T -> * -> * where
  JS   :: ((a -> Program (JSI t) ()) -> Program (JSI t) ()) 
       -> JS t a
  ...
\end{verbatim}
For atomic
computations we just produce a list of instructions from the continuation. 
When translating possibly blocking code we directly translate that continuation
into JavaScript functions. This gives us the ability to handle 
computations as values in JavaScript and store them if needed.

Blocking operations just store the rest of their computation in a queue.
When the event to unblock occurs the pending computation is registered 
as a callback that will be executed as soon as the current computation
is done.

On top of our \JS-monad we provide ways of specifying (typed)
interfaces to JavaScript capabilities, a Foreign Function Interface.
\begin{verbatim}
alert :: JSString -> JS t ()
alert = fun "alert"

getElementById :: JSString -> JSObject -> JS t JSCanvas
getElementById = invoke "getElementById"
\end{verbatim}
Notice, that calling a JavaScript function or method is done by giving its
name to one of the provided combinators. Types can be specialized using 
a Haskell type annotation. A flexible and easy to use approach.
\end{comment}

\begin{comment}
\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

Compiling
\begin{itemize}
\item Short introduction to the compiler interface (signature).
\item Core work done by translating \Src{Program (JSI t) ()}
into a list of \Src{Stmt}s.
\item Introduce statement type, give a short description of 
each constructor (just in the comments)
\item Basic idea: Each \JSI~nstruction is translated 
into a sequence of statements and these are then
concatenated together.
\item Look at interesting parts
\item TODO: Which parts are interesting? Most parts are too technical
\item Show how a branch is compiled (TODO: \Src{extractProgramJS} lets things look messy)
\item Talk about how \Src{JS\_Fix} is compiled.
\item TODO: Understand why fix works.
\item Difference between compilation of a function and a continuation
\item Function \Src{\textbackslash a -> JS \$ \textbackslash k -> singleton (JS\_Return a) >>= k}
\item TODO: Why \Src{>>= k}?
\item Return the result of the current continuation
\item Continuation \Src{\textbackslash \_ -> JS \$ \textbackslash k -> k ()}
\item Just execute it instead of passing it on further. No return value!
\item We use expression sharing through observable sharing (reference Andys paper).
\end{itemize}

\begin{itemize}
\item If we transliterate, we have straight line code, can not pause.
    (Wait for Mvar, for example)
\item If we CPS translate, we can use continuations to capture the
   notion of a paused thread. Works well.
   Problems:
  \begin{itemize}
   \item Can not translate functions, how do they get there return value
   \item (Assumes straight line code.)
   \item Also, the code becomes unreadable to anyone except a die-hard 
       compiler freak.
  \end{itemize}
\end{itemize}
 
Choice:
\begin{itemize}
\item We support both!
\item Phantom argument to JS
\item A = Atomic, B = Blockable.
\end{itemize}
\end{comment}





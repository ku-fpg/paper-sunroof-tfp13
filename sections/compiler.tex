 
\section{The Sunroof Compiler}
\label{sec:compiler}

Given the language, and monadic-reification, how do we compile this language?
Figure \ref{fig:structure} shows how Sunroof is structured.

\Figure%
{fig:structure}%
{figures/sunroof-structure.pdf}%
{The structure of Sunroof.}

Through the \JS-monad we produce a \Src{Program (JSI t) ()} instance. We 
translate such a program into a list of statements (\Src{Stmt}) by matching over 
the \JSI constructors.
\begin{verbatim}
data Stmt 
  = AssignStmt Rhs Expr       -- Assignment
  | DeleteStmt Expr           -- Delete reference
  | ExprStmt Expr             -- Expression as statement
  | ReturnStmt Expr           -- Return statement
  | IfStmt Expr [Stmt] [Stmt] -- If-Then-Else statement
  | WhileStmt Expr [Stmt]     -- While loop
  | CommentStmt String        -- Comment
\end{verbatim}
The constructors of \Src{Stmt} are straight forward and
directly represent the different statements one can write
in JavaScript.

To translate a \Src{Program (JSI t) ()} into statements we
have to translate it into a \Src{ProgramView} since 
Operational prohibits us from working on \Src{Program} directly.
\Src{ProgramView} can then be taken apart to translate 
the \JSI nstructions inside.
\begin{verbatim}
compile :: Program (JSI t) () -> CompM [Stmt]
compile p = eval (view p)
  where
    eval :: ProgramView (JSI t) () -> CompM [Stmt]
    ...
\end{verbatim}
The compilation monad \Src{CompM} provides us with 
the compiler options and a supply of fresh integer
values to generate new variable when needed.

To get a feel for how the compiler works, lets take a look at 
the case for \Src{JS\_Assign}. Recall its signature from 
Figure \ref{fig:jsi-definition}:
\begin{verbatim}
JS_Assign :: Sunroof a => JSSelector a -> a -> JSObject -> JSI t ()
\end{verbatim}
This instruction assigns a new value \Src{a} to the attribute
selected by the \Src{JSSelector a} of the \Src{JSObject}.
\begin{verbatim}
eval (JS_Assign sel a obj :>>= k) = do
  (stmts0,val) <- compileExpr (unbox a)
  stmts1 <- compile (k ())
  return (  stmts0 
         ++ [ AssignStmt (DotRhs (unbox obj) 
                                 (unboxSelector sel)) 
                         val ] 
         ++ stmts1 )
\end{verbatim}
First we compile the expression that will be assigned. That
produces a series of statements to compute the expression and 
the expressions value \Src{val}.
Then we compile the rest of the Sunroof computation \Src{k}. Since 
the assignment does not produce a interesting value (it has type \Src{JSI t ()}),
we can pass unit to \Src{k}.
We return the concatenation of the produced statements with a statement 
for the assignment in between. The \Src{unbox} functions reveal the 
\Src{Expr} inside of our Sunroof wrapper types.

Lets now look at a more interesting part of the compiler: The translation of 
branches.
Recall the \JSI constructor for branches from Figure \ref{fig:jsi-definition}.
\begin{verbatim}
JS_Branch :: (SunroofThread t, SunroofArgument a, Sunroof bool) 
          => bool -> JS t a -> JS t a  -> JSI t a
\end{verbatim}
Aside of the fact that branches may return \Src{SunroofArgument}s
instead of just \Src{Sunroof} values the translation seems to 
be straight forward (Figure \ref{fig:branch-translation}).
\begin{figure}[h]
\begin{verbatim}
eval (JS_Branch b c1 c2 :>>= k) = do
  (src0, res0) <- compileExpr (unbox b)
  res :: a <- jsValue
  let bindResults :: a -> JS t ()
      bindResults res' =
        sequence_ [ single $ JS_Assign_ v (box $ e :: JSObject)
                  | (Var v, e) <- jsArgs res `zip` jsArgs res' ]
  src1 <- compile $ extractProgramJS bindResults c1
  src2 <- compile $ extractProgramJS bindResults c2
  rest <- compile (k res)
  return (src0 ++ [ IfStmt res0 src1 src2 ] ++ rest)
\end{verbatim}
\caption{Naive translation of branches in Sunroof.}
\label{fig:branch-translation}
\end{figure}
First we generate the statements to compute the branching condition.
Then we generate unique names for each of the values returned in 
either branch. \Src{bindResults} generates the assignments of
the returned values to the generated variables. When compiling 
the branches we use the function \Src{extractProgramJS}.
\begin{verbatim}
extractProgramJS :: (a -> JS t ()) -> JS t a -> Program (JSI t) ()
extractProgramJS k m = unJS (m >>= k) return
\end{verbatim}
It passes the result of a computation \Src{m} 
into the given function \Src{f} and
closes the continuation inside \JS~with \Src{return},
such that the result is a \Src{Program} containing
all instructions of \Src{m >>= k}.

After we have compiled both branches we compile the rest and
construct the list of statements in a canonical fashion.

This works perfectly when we work in the atomic threading model,
but it causes problems when inside the blocking model. To 
see what can go wrong lets look at a small example.
(TODO: Explain callcc in continuation section)
\begin{verbatim}
branchFail = do
  b <- ifB (true :: JSBool)
           (callcc $ \k -> do comment "True Case"
                              goto k true :: JSB JSBool)
           (callcc $ \k -> do comment "False Case"
                              goto k false :: JSB JSBool)
  fun "CallAfterIf" $$ b
\end{verbatim}
In either case of the initial branch we want to do something
with our current continuation. We insert a comment for 
our orientation and then call our current continuation to 
proceed with a boolean value that depends on the branch.
After our branch we call a function with the returned boolean value.
(TODO: Is there a simpler example that demonstrates the problem?)
What will this be translated to?
\begin{verbatim}
var v8 = function() {
  if(true){
    var v2 = function(v1) {
      var v0 = v1;
    };
    /* True Case */
    v2(true);
  } else {
    var v5 = function(v4) {
      var v0 = v4;
    };
    /* False Case */
    v5(false);
  }
  CallAfterIf(v0);
};
v8();
\end{verbatim}
We can see the branching statement and the function call afterwards.
Inside each branch we can also see a function definition the inserted 
comment and a call to the defined function. The function definitions 
\Src{v2} and \Src{v5} correspond to the continuation \Src{k} in 
our \Src{callcc} calls. So we can see that the current continuations 
captured the assignment that has to be done at the end of each branch 
to pass on the result value. But the assignments are hidden inside 
the scope of the continuations and, because of that, \Src{v0} is 
defined when \Src{CallAfterIf} is applied to it.

So how can we fix this? If we are working within the blocking 
threading model, we have to handle branches differently.
\begin{verbatim}
eval (JS_Branch b c1 c2 :>>= k) = 
  case evalStyle (ThreadProxy :: ThreadProxy t) of
    A -> compileBranch_A b c1 c2 k
    B -> compileBranch_B b c1 c2 k
\end{verbatim}
\Src{evalStyle} is provided by the class \Src{SunroofThread} and
provides the threading model currently used. The call to \Src{compileBranch\_A}
executes our naive definition from Figure \ref{fig:branch-translation}.
\begin{verbatim}
compileBranch_B b c1 c2 k = do
  fn_e <- compileContinuation $
            \a -> blockableJS $ JS $ \k2 -> k a >>= k2
  fn <- newVar
  (src0, res0) <- compileExpr (unbox b)
  src1 <- compile $ extractProgramJS (apply (var fn)) c1
  src2 <- compile $ extractProgramJS (apply (var fn)) c2
  return ( [mkVarStmt fn fn_e] ++ src0 ++ [ IfStmt res0 src1 src2 ])
\end{verbatim}
(TODO: Talk about \Src{blockableJS})
We can see that the rest of our computation is captured in a
continuation \Src{fn\_e} that takes the results of our branching
as arguments. We assign that computation to the new variable \Src{fn}
to avoid the duplication of the continuation in the produced sources.
The key difference lays in the call to \Src{extractProgramJS}. Instead
of creating bindings for each returned value we apply the produced
continuation to the returned values and like that make them visible for
the ongoing computation, even if we capture our current continuation. 
Now the produced code looks like this:
\begin{verbatim}
var v11 = function() {
  var v2 = function(v0) {
    CallAfterIf(v0);
  };
  if(true){
    var v5 = function(v3) {
      v2(v3);
    };
    /* True Case */
    v5(true);
  } else {
    var v9 = function(v7) {
      v2(v7);
    };
    /* False Case */
    v9(false);
  }
};
v11();
\end{verbatim}
We can see that the function call after the branch is captured by the 
continuation \Src{v2} and that continuation is called with the 
return values as parameters inside each branch.

\TODO{Look at another interesting part: Fix? Function?}

The compiler can be called through two functions. 
One for each threading model (TODO: Maybe remove the string argument from JSB).
\begin{verbatim}
sunroofCompileJSA :: Sunroof a 
                  => CompilerOpts -> String -> JS A a  -> IO String
sunroofCompileJSB :: CompilerOpts -> String -> JS B () -> IO String
\end{verbatim}

\begin{comment}
Given the language, and monadic-reification, how do we compile this language?
Figure \ref{fig:structure} shows how Sunroof is structured.
On the lowest level we provide an untyped expression language \Src{Expr}
that describes JavaScript expressions. 
To provide type safety when using Sunroof we create
wrappers for each type we want to represent, e.g. \Src{JSNumber} or \Src{JSString}.
The \Src{Sunroof} type class provides an 
interface to create wrapped and unwrapped
instances of our expressions. Based on the wrappers we can provide 
operations specific to a certain type, e.g. a \Src{Num} instance
for \Src{JSNumber} or a \Src{Monoid} instance for \Src{JSString}.



This technique enables us to utilize  Haskells type system when writing JavaScript
and offers an easy way to add new types when needed~\cite{Svenningsson:12:CombiningEmbedding}.
By using phantom types we can also provide more advanced types,
like \Src{JSArray a}.

The next layer provides JavaScript instructions through the type \JSI.
They represents abstract statements. While expressions and values
represented with type wrappers are assumed to be free of side-effects,
the instructions model side-effects in JavaScript. Examples for Instructions
are assignment of an attribute or the application of a function.
\begin{verbatim}
data JSI :: T -> * -> * where
  JS_Assign :: (...) => JSSelector a -> a -> JSObject -> JSI t ()
  JS_Invoke :: (...) => a -> JSFunction a r -> JSI t r
  JS_Branch :: (...) => bool -> JS t a -> JS t a  -> JSI t a
  ...
\end{verbatim}
The \JS-monad with its combinators builds a sequence of 
\JSI{}nstructions through the operational
package~\cite{Hackage:10:Operational,Apfelmus:10:Operational}.
All constraints required on instructions are introduced by their 
constructors.
As mentioned earlier the \JS-monad comes in two threading flavors, 
parameterized using a phantom type.
Internally the \JS-monad is implemented using CPS on the 
underlying \Src{Program} type from Operational. 
\begin{verbatim}
data JS :: T -> * -> * where
  JS   :: ((a -> Program (JSI t) ()) -> Program (JSI t) ()) 
       -> JS t a
  ...
\end{verbatim}
For atomic
computations we just produce a list of instructions from the continuation. 
When translating possibly blocking code we directly translate that continuation
into JavaScript functions. This gives us the ability to handle 
computations as values in JavaScript and store them if needed.

Blocking operations just store the rest of their computation in a queue.
When the event to unblock occurs the pending computation is registered 
as a callback that will be executed as soon as the current computation
is done.

On top of our \JS-monad we provide ways of specifying (typed)
interfaces to JavaScript capabilities, a Foreign Function Interface.
\begin{verbatim}
alert :: JSString -> JS t ()
alert = fun "alert"

getElementById :: JSString -> JSObject -> JS t JSCanvas
getElementById = invoke "getElementById"
\end{verbatim}
Notice, that calling a JavaScript function or method is done by giving its
name to one of the provided combinators. Types can be specialized using 
a Haskell type annotation. A flexible and easy to use approach.
\end{comment}

\begin{comment}
\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

Compiling
\begin{itemize}
\item Short introduction to the compiler interface (signature).
\item Core work done by translating \Src{Program (JSI t) ()}
into a list of \Src{Stmt}s.
\item Introduce statement type, give a short description of 
each constructor (just in the comments)
\item Basic idea: Each \JSI~nstruction is translated 
into a sequence of statements and these are then
concatenated together.
\item Look at interesting parts
\item TODO: Which parts are interesting? Most parts are too technical
\item Show how a branch is compiled (TODO: \Src{extractProgramJS} lets things look messy)
\item Talk about how \Src{JS\_Fix} is compiled.
\item TODO: Understand why fix works.
\item Difference between compilation of a function and a continuation
\item Function \Src{\textbackslash a -> JS \$ \textbackslash k -> singleton (JS\_Return a) >>= k}
\item TODO: Why \Src{>>= k}?
\item Return the result of the current continuation
\item Continuation \Src{\textbackslash \_ -> JS \$ \textbackslash k -> k ()}
\item Just execute it instead of passing it on further. No return value!
\item We use expression sharing through observable sharing (reference Andys paper).
\end{itemize}

\begin{itemize}
\item If we transliterate, we have straight line code, can not pause.
    (Wait for Mvar, for example)
\item If we CPS translate, we can use continuations to capture the
   notion of a paused thread. Works well.
   Problems:
  \begin{itemize}
   \item Can not translate functions, how do they get there return value
   \item (Assumes straight line code.)
   \item Also, the code becomes unreadable to anyone except a die-hard 
       compiler freak.
  \end{itemize}
\end{itemize}
 
Choice:
\begin{itemize}
\item We support both!
\item Phantom argument to JS
\item A = Atomic, B = Blockable.
\end{itemize}
\end{comment}





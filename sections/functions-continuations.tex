 
\section{Functions and Continuations}
\label{sec:functions-continuations}

Functions are first class values in Haskell and JavaScript.
To represent a function in Sunroof, we introduce the type 
\Src{JSFunction $\alpha$ $\beta$}. This represents a function
$\alpha \rightarrow \beta$ in JavaScript. Functions should
be able to take more then one argument, which means a 
\Src{Sunroof $\alpha$} constraint would be to restrictive.
Thus we introduced \Src{SunroofArgument} to constraint the 
types that may be used as arguments for functions.
\begin{verbatim}
class SunroofArgument args where
  jsArgs   :: args -> [Expr]
  jsValue  :: (UniqM m) => m args
  ...
\end{verbatim}
It enables use to convert each argument into its expression
through \Src{jsArgs}, which is used to supply the
arguments to a function call. \Src{jsValue} generates
new unique names for each argument, which is needed when compiling
the function itself to a value. 

Since the usefulness of partial application is questionable in
the context of JavaScript, we choose to only permit uncurried functions,
by providing instances for tuples of sunroof values.
\begin{verbatim}
instance (Sunroof a, Sunroof b) => SunroofArgument (a,b) where
  jsArgs ~(a,b) = [unbox a, unbox b]
  jsValue = liftM2 (,) jsVar jsVar
\end{verbatim}
Remember that each \Src{Sunroof} value already has to be 
a \Src{SunroofArgument}, which also enables us to pass a single argument
to a function. 

To create a JavaScript function we provide the \Src{function} combinator.
\begin{verbatim}
function :: (SunroofArgument a, Sunroof b) 
         => (a -> JS A b)  -> JS t (JSFunction a b)
\end{verbatim}
As a function can have side-effects its computation and result has to be 
expressed through the \JS-monad. Again, due to observable allocation,
the creation of a function is considered a side-effect.

A function can be applied to arguments through the \Src{apply} combinator
or the \Src{\$\$} operator.
Functions can only be applied in the \JS-monad since they can have side-effects.
\begin{verbatim}
apply, ($$) :: (SunroofArgument a, Sunroof b) 
            => JSFunction args ret -> args -> JS t ret
\end{verbatim}
Creation and application are implemented using the \Src{JS\_Function}
and \Src{JS\_Invoke} instructions introduced in 
Figure \ref{fig:jsi-definition}.

\Src{JSContinuation} models continuations as they are used 
inside the \JS-monad. They were introduced to work and actively manipulate 
continuations on the Sunroof level. Technically they are only
specializations of the general function type, that are 
restricted to the second threading models. As the continuations
are meant to be a representation of side-effects -- 
ongoing computations inside the \JS-monad -- and might 
not terminate, they do not return a value. As with functions 
there is a combinator to create and apply a continuation.
\begin{verbatim}
continuation :: (SunroofArgument a) 
             => (a -> JS B ()) -> JS t (JSContinuation a)
goto         :: (SunroofArgument a) 
             => JSContinuation a -> a -> JS t b
\end{verbatim}
The major difference is that a call to \Src{goto} will never
return, as it execute the given continuation and abandons the 
current one. This allows \Src{goto} to be fully polymorphic
on its result. 

To give access to the internal continuations of the \JS-monad
Sunroof offers the powerful call-with-current-continuation 
function \Src{callcc} \TODO{cite for \Src{callcc}}.
\begin{verbatim}
callcc :: SunroofArgument a 
       => (JSContinuation a -> JS B a) -> JS B a
\end{verbatim}
It enables us to use the current continuation, which 
models everything that would usually happen after the call
to \Src{callcc}. 
\begin{verbatim}
callcc f = JS $ \ k -> unJS 
    (continuation (\a -> JS $ \ _ -> k a) >>= f) k

unJS :: JS t a -> (a -> Program (JSI t) ()) -> Program (JSI t) ()
\end{verbatim}
The implementation of \Src{callcc} is interesting,
because it shows how the \Src{Program}-continuation is translated 
into a \Src{JSContinuation} that is passed to the given function \Src{f}.
Section \ref{sec:threading-models} will show why this function
is important for Sunroof and what it is used for.

Functions and continuations are similar and connected 
to each other, as can be seen in Figure \ref{fig:func-cont}.
\Figure%
{fig:func-cont}%
{figures/sunroof-func-cont.pdf}%
{How functions and continuations relate between the Haskell- and Sunroof-domain.}%
We can go back and forth between the Haskell and the Sunroof
representation of a function or continuation. But once a function
was specialized to a continuation it is not possible to go back,
because continuations only model the side-effect, but do 
not return anything.


\begin{comment}

\begin{table}
\caption{Reifying and calling JavaScript functions}
\begin{center}
\begin{tabular}{r@{\quad}c@{\quad}c@{\quad}c@{\quad}c}
\hline\rule{0pt}{12pt}%

                & Monadic Function      & Reification   & Object in     & Invocation\\
                & in Haskell            & Function      & Javascript    & Function\\
\hline\rule{0pt}{12pt}%
  Functions
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{A}~\beta$
  & \Src{function}
  & \Src{JSFunction}~$\alpha~\beta$
  & \Src{apply} \\
  Continuations
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{B}~\Src{()}$
  & \Src{continuation}
  & \Src{JSContinuation}~$\alpha$
  & \Src{goto}\\
\hline
\end{tabular}
\end{center}
\end{table}

\end{comment}

\begin{comment}
\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

\begin{itemize}
\item Functions are first class members in Haskell and JavaScript
\item But in JavaScript they are limited (no partial application)
\item That leads to type for functions \Src{JSFunction a b}
\item Functions can take more then one argument; \Src{Sunroof} insufficient: \Src{SunroofArgument}
\item \Src{SunroofArgument} is prerequisite for \Src{Sunroof},
because all JS objects are parameters but pairs of them are not 
JS objects.
\item Introduce \Src{SunroofArgument}.
\item So function in JS are not curried (partial application is questionable in JS)
\item Create a function with \Src{function} combinator.
\item Function creation is a monadic effect for the same reason 
a record creation (\Src{JSTuple}). It represents observable
allocation and we usually want one reference to a function 
instead of coping its definition everywhere.
\item Calling a function or method can have a side-effect
\item That is why the operator \Src{\$\$} for function application is monadic to.
\item All these operations do is to produce \Src{JS\_Function} and \Src{JS\_Invoke}
instructions.
\item Continuations are basically the same as functions at this level.
\item Created with \Src{continuation} and called with \Src{goto}.
\item Implementation of \Src{goto} is interesting. Ignores 
the current continuation in the \JS-monad and continues with the given one
by actually invoking the JavaScript function representing it.
\item Major difference in translation between both on compiler level (section \ref{sec:compiler})
\item \TODO{Further detail on continuations; Here or somewhere else?}
\end{itemize}
\end{comment}






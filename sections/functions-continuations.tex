 
\section{JavaScript Functions and Continuations}
\label{sec:functions-continuations}

Functions are first class values in Haskell and JavaScript.
To represent a function in Sunroof, we introduce the type 
\Src{JSFunction $\alpha$ $\beta$}. This represents a function
$\alpha \rightarrow \beta$ in JavaScript. Functions should
be able to take more then one argument, which means a 
\Src{Sunroof $\alpha$} constraint would be to restrictive.
Thus we introduced \Src{SunroofArgument} to constraint the 
types that may be used as arguments for functions.
\begin{verbatim}
class SunroofArgument args where
  jsArgs   :: args -> [Expr]
  jsValue  :: (UniqM m) => m args
  ...
\end{verbatim}
It enables use to convert each argument into its expression
through \Src{jsArgs}. This used when calling a function to 
provide the arguments to a call. \Src{jsValue} generates
new unique names for each argument, which is needed when compiling
the function itself to a value. 

Since the usefulness of partial application is questionable in
the context of JavaScript, we choose to only permit uncurried functions,
by providing instances for tuples of sunroof values.
\begin{verbatim}
instance (Sunroof a, Sunroof b) => SunroofArgument (a,b) where
  jsArgs ~(a,b) = [unbox a, unbox b]
  jsValue = liftM2 (,) jsVar jsVar
\end{verbatim}
Remember that each \Src{Sunroof} value already has to be 
a \Src{SunroofArgument}, which also enables us to pass a single argument
to a function. 

To create a JavaScript function we provide the \Src{function} combinator.
\begin{verbatim}
function :: (SunroofArgument a, Sunroof b) 
         => (a -> JS A b)  -> JS t (JSFunction a b)
\end{verbatim}
As a function can have side-effects its computation and result has to be 
expressed through the \JS-monad. Again, due to observable allocation,
the creation of a function is considered a side-effect.

A function can be applied to arguments through the \Src{apply} combinator
or the \Src{\$\$} operator.
Functions can only be applied in the \JS-monad since they can have side-effects.
\begin{verbatim}
apply, ($$) :: (SunroofArgument a, Sunroof b) 
            => JSFunction args ret -> args -> JS t ret
\end{verbatim}
Creation and application are implemented using the \Src{JS\_Function}
and \Src{JS\_Invoke} instructions introduced earlier.

One of the threading models of Section \ref{sec:threading-models} 
requires continuations on the JavaScript level. For this purpose we
also model continuations in Sunroof. Technically they are only
specializations of the general function type, that are 
restricted to the second threading models.
\begin{verbatim}
continuation :: (SunroofArgument a) => (a -> JS B ()) -> JS t (JSContinuation a)
goto :: (SunroofArgument a) => JSContinuation a -> a -> JS t b
\end{verbatim}
The major difference is that a call to \Src{goto} will never
return. This is the reason why \Src{goto} is fully polymorphic
on its result. Functions and continuations are similar and connected 
to each other, as can be seen in Figure \ref{fig:func-cont}.
\Figure%
{fig:func-cont}%
{figures/sunroof-func-cont.pdf}%
{How functions and continuations relate between the Haskell- and JS-domain.}%
We can go back and forth between the Haskell and the Sunroof
representation of a function or continuation. But once a function
was specialized to a continuation it is not possible to go back,
because continuation can only exists in the \Src{B}locking threading model.


\begin{comment}

\begin{table}
\caption{Reifying and calling JavaScript functions}
\begin{center}
\begin{tabular}{r@{\quad}c@{\quad}c@{\quad}c@{\quad}c}
\hline\rule{0pt}{12pt}%

                & Monadic Function      & Reification   & Object in     & Invocation\\
                & in Haskell            & Function      & Javascript    & Function\\
\hline\rule{0pt}{12pt}%
  Functions
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{A}~\beta$
  & \Src{function}
  & \Src{JSFunction}~$\alpha~\beta$
  & \Src{apply} \\
  Continuations
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{B}~\Src{()}$
  & \Src{continuation}
  & \Src{JSContinuation}~$\alpha$
  & \Src{goto}\\
\hline
\end{tabular}
\end{center}
\end{table}

\end{comment}

\begin{comment}
\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

\begin{itemize}
\item Functions are first class members in Haskell and JavaScript
\item But in JavaScript they are limited (no partial application)
\item That leads to type for functions \Src{JSFunction a b}
\item Functions can take more then one argument; \Src{Sunroof} insufficient: \Src{SunroofArgument}
\item \Src{SunroofArgument} is prerequisite for \Src{Sunroof},
because all JS objects are parameters but pairs of them are not 
JS objects.
\item Introduce \Src{SunroofArgument}.
\item So function in JS are not curried (partial application is questionable in JS)
\item Create a function with \Src{function} combinator.
\item Function creation is a monadic effect for the same reason 
a record creation (\Src{JSTuple}). It represents observable
allocation and we usually want one reference to a function 
instead of coping its definition everywhere.
\item Calling a function or method can have a side-effect
\item That is why the operator \Src{\$\$} for function application is monadic to.
\item All these operations do is to produce \Src{JS\_Function} and \Src{JS\_Invoke}
instructions.
\item Continuations are basically the same as functions at this level.
\item Created with \Src{continuation} and called with \Src{goto}.
\item Implementation of \Src{goto} is interesting. Ignores 
the current continuation in the \JS-monad and continues with the given one
by actually invoking the JavaScript function representing it.
\item Major difference in translation between both on compiler level (section \ref{sec:compiler})
\item TODO: Further detail on continuations; Here or somewhere else?
\end{itemize}
\end{comment}






 
\section{JavaScript Functions and Continuations}
\label{sec:functions-continuations}

Given these threading models, we can realize both as 
JavaScript objects. 
\begin{verbatim}
function     :: (...) => (a -> JS A b)  -> JS t (JSFunction a b)
continuation :: (...) => (a -> JS B ()) -> JS t (JSContinuation a)
\end{verbatim}
\Src{JSFunction a b} and \Src{JSContinuation a},
like \Src{JSObject} and others, are realized as objects
in JavaScript. Thus they can be passed as arguments, returned
from functions and stored in mutable structures.

\Figure%
{fig:func-cont}%
{figures/sunroof-func-cont.pdf}%
{How functions and continuations relate between the Haskell- and JS-domain.}%

Functions and continuations can be called using \Src{apply}
and \Src{goto} respectively. \Src{apply} calls the function
and returns, \Src{goto} calls the continuation, but never
returns.
\begin{verbatim}
apply :: (...) => JSFunction args ret -> args -> JS t ret
goto  :: (...) => JSContinuation args -> args -> JS t a
\end{verbatim}

\begin{table}
\caption{Reifying and calling JavaScript functions}
\begin{center}
\begin{tabular}{r@{\quad}c@{\quad}c@{\quad}c@{\quad}c}
\hline\rule{0pt}{12pt}%

                & Monadic Function      & Reification   & Object in     & Invocation\\
                & in Haskell            & Function      & Javascript    & Function\\
\hline\rule{0pt}{12pt}%
  Functions
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{A}~\beta$
  & \Src{function}
  & \Src{JSFunction}~$\alpha~\beta$
  & \Src{apply} \\
  Continuations
  & $\alpha\rightarrow\ $\Src{JS}$_\Src{B}~\Src{()}$
  & \Src{continuation}
  & \Src{JSContinuation}~$\alpha$
  & \Src{goto}\\
\hline
\end{tabular}
\end{center}
\end{table} 

\subsubsection{RESOURCES - REMOVE WHEN FINISHED}

\begin{itemize}
\item Functions are first class members in Haskell and JavaScript
\item But in JavaScript they are limited (no partial application)
\item That leads to type for functions \Src{JSFunction a b}
\item Functions can take more then one argument; \Src{Sunroof} insufficient: \Src{SunroofArgument}
\item \Src{SunroofArgument} is prerequisite for \Src{Sunroof},
because all JS objects are parameters but pairs of them are not 
JS objects.
\item Introduce \Src{SunroofArgument}.
\item So function in JS are not curried (partial application is questionable in JS)
\item Create a function with \Src{function} combinator.
\item Function creation is a monadic effect for the same reason 
a record creation (\Src{JSTuple}). It represents observable
allocation and we usually want one reference to a function 
instead of coping its definition everywhere.
\item Calling a function or method can have a side-effect
\item That is why the operator \Src{\$\$} for function application is monadic to.
\item All these operations do is to produce \Src{JS\_Function} and \Src{JS\_Invoke}
instructions.
\item Continuations are basically the same as functions at this level.
\item Created with \Src{continuation} and called with \Src{goto}.
\item Implementation of \Src{goto} is interesting. Ignores 
the current continuation in the \JS-monad and continues with the given one.
\item TODO: Further detail on continuations; Here or somewhere else?
\end{itemize}






